<!DOCTYPE HTML>
<html lang="en-us">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>r.va.gg</title>
    <link rel="stylesheet" href="/style.css" type="text/css">
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://r.va.gg/atom.xml" />
    <script type="text/javascript" src="http://use.typekit.com/swo4snt.js"></script>
    <script type="text/javascript">try{Typekit.load()}catch(e){}</script>  
    <script type="text/javascript">
      var _gaq = _gaq || []
      _gaq.push(['_setAccount', 'UA-21373682-1'])
      _gaq.push(['_trackPageview'])
      setTimeout('_gaq.push(["_trackEvent", "15_seconds", "read"])', 15000)
      !(function () {
        var ga = document.createElement('script')
        ga.type = 'text/javascript'
        ga.async = true
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'
        var s = document.getElementsByTagName('script')[0]
        s.parentNode.insertBefore(ga, s)
      }())
    </script>
  </head>
  <body>

    <section class="content">
      <h1>
        <a href="/">r.va.gg</a>
      </h1>

      <section class="nav">
        <section class="me">
          <span>Find me</span>
          <ul>
            <li>on <a href="https://twitter.com/rvagg">Twitter / @rvagg</a></li>
            <li>on <a href="https://github.com/rvagg">GitHub / @rvagg</a></li>
          </ul>
        </section>
        <section class="recent">
          <span>Recent posts</span>
          <ul>
            
 
                <li><a href="/2014/06/nodeschool-comes-to-australia.html">NodeSchool comes to Australia</a></li>
              
 
 
                <li><a href="/2014/06/why-i-dont-use-nodes-core-stream-module.html">Why I don&#39;t use Node&#39;s core &#39;stream&#39; module</a></li>
              
 
 
                <li><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html">Testing code against many Node versions with Docker</a></li>
              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
          </ul>
        </section>
      </section>
      <div style="clear: both;"></div>

      

<div id="for">
  

    <section class="post-content">

      <h2 id="nodeschool-comes-to-australia"><a href="/2014/06/nodeschool-comes-to-australia.html">NodeSchool comes to Australia</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on June 14, 2014</p>
        <p class="link"><a href="/2014/06/nodeschool-comes-to-australia.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2014/06/nodeschool-comes-to-australia.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p><strong><a href="http://nodeschool.io">NodeSchool</a></strong> has its genesis ultimately at NodeConf 2013 where <a href="https://twitter.com/substack">@substack</a> introduced us to <a href="https://github.com/substack/stream-adventure">stream-adevnture</a>. I took the concept home to <a href="http://campjs.com/">CampJS</a> and wrote <strong><a href="https://github.com/rvagg/learnyounode/">learnyounode</a></strong> for the <em>introduction to Node.js</em> workshop I was to run. As part of the process I extracted a package called <a href="https://github.com/rvagg/workshopper">workshopper</a> to do the work of making a terminal workshop experience. Most of the logic originally came from stream-adventure. A short time after CampJS, I created <a href="https://github.com/rvagg/levelmeup">levelmeup</a> for <a href="http://nodeconf.eu/">NodeConf.eu</a> and suddenly we had a selection of what have come to be known as <em>&quot;workshoppers&quot;</em>. At NodeConf.eu, <a href="https://twitter.com/brianloveswords">@brianloveswords</a> suggested the NodeSchool concept and registered the <a href="http://nodeschool.io">domain</a>, @substack provided the artwork and the ball was rolling.</p>
<p>Today, workshopper is depended on by 22 packages in npm, most of which are workshoppers that you can install and use to learn aspects of Node.js or JavaScript in general. The curated list of usable workshoppers is maintained at <a href="http://nodeschool.io">nodeschool.io</a>.</p>
<p>learnyounode itself is now being downloaded at a rate of roughly 200 <em>per day</em>. That&#39;s at least 200 more people each day wanting to learn how to <em>do Node.js</em>.</p>
<div style="margin: 0 auto; text-align: center;">

<img src="https://nodei.co/npm-dl/learnyounode.png?months=6" alt="learnyounode downloads">

</div>

<p>I can&#39;t recall exactly how <em>&quot;NodeSchool IRL&quot;</em> events started but it was probably <a href="http://twitter.com/maxogden">@maxogden</a> who has been responsible for a large number of these events. There have now been over 30 of these events around the world and the momentum is only picking up steam. The beauty of this format is that it&#39;s low-cost and low-effort to make it happen. All you need is a venue where nerds can show up with their computers and some basic guidance. There have even been a few events that were without experienced Node.js mentors but that&#39;s no great barrier as the lessons are largely self-guided and work particularly well when pairs or groups of people work together on solutions.</p>
<div style="margin: 0 auto; text-align: center;">

<img src="https://raw.githubusercontent.com/nodeschool/nodeschool.github.io/master/images/nodeschool-hex.png" style="width: 300px;">

</div>

<h2>NodeSchool comes to Australia</h2>
<p>It&#39;s surprising that so far, given all of the NodeSchool activity around the world, that we haven&#39;t had a single NodeSchool event in Australia. CampJS had learnyounode last year and this year there were <a href="https://github.com/nodeschool/discussions/issues/323">3 brand new workshoppers</a> introduced there, so it&#39;s the closest thing we&#39;ve had.</p>
<p>Next weekend, on the <strong>21st of June</strong>, we are attempting a <strong>coordinated Australian NodeSchool</strong> event. At the moment, that coordination amounts to having events hosted in Sydney, Melbourne and Hobart, unfortunately the timing has been difficult for Brisbane and we haven&#39;t managed to bring anyone else out of the woodwork. But, we will be attempting to do this regularly, plus we&#39;d like to encourage meet-up hosts to use the format now and again with their groups.</p>
<h2>NodeSchool in Sydney</h2>
<p>I&#39;ll be at NodeSchool in Sydney next weekend. It will be proudly hosted by <a href="http://nicta.com.au/">NICTA</a> who have a space for up to 60 people. NICTA are currently doing some interesting work with WebRTC, you should catch up with <a href="https://twitter.com/DamonOehlman">@DamonOehlman</a> if this is something you&#39;re interested in. <a href="https://www.tabcorp.com.au/">Tabcorp</a> will also be a major sponsor of the event. Tabcorp have been building a new digital team with the back-end almost entirely in Node.js. They are also doing a great job engaging and contributing to existing and new open source projects. They are also hiring so be sure to catch up with <a href="https://twitter.com/romainprieto">@romainprieto</a> if you&#39;re doing PHP, Java or some other abomination and want to be doing Node!</p>
<p>Thanks to the sponsorship, we&#39;ll be able to provide some catering for the event. Currently we&#39;re looking at providing lunch but we may be expanding that to providing some breakfast treats. We&#39;ll also be providing refreshments for everyone attending throughout the day.</p>
<p>Start time is 9.30am, end is 4pm. The plan is to spend the first half of the day doing introductory Node.js which will mainly mean working through learnyounode. The second half of the day will be less structured and we&#39;ll encourage attendees to work on other workshoppers that they find interesting. Thankfully we have some amazing Node.js programmers in Sydney and they&#39;ll be available as mentors.</p>
<p>We are currently <em>selling</em> tickets for $5, the money will contribute towards the event, there is no profit involved here. We don&#39;t <em>need</em> to charge for the event but given the generally dismal turnout for tech meet-ups that are free we feel that providing a small commitment barrier will help us maximise the use of the space we have available. <strong>If the money is a barrier for you please contact us!</strong> We don&#39;t want anyone to miss out. Also, we have special &quot;mentor&quot; tickets available for experienced Node.js programmers who are able to assist. If you think you fit into this category please contact us also.</p>
<p>You can <strong>sign up for Sydney NodeSchool at <a href="https://ti.to/nodeschool/sydney-june-2014/"><a href="https://ti.to/nodeschool/sydney-june-2014/">https://ti.to/nodeschool/sydney-june-2014/</a></a></strong>. If you are tempted, don&#39;t sit on the fence because spots are limited and as of writing the tickets are almost 1/2 gone.</p>
<h2>NodeSchool in Melbourne</h2>
<p>NodeSchool in Melbourne is being supported by <a href="http://www.thoughtworks.com/">ThoughtWorks</a> who have been doing Node in Australia for a while now. If you&#39;re interested in their services or want to chat about employment opportunities you should catch up with <a href="https://github.com/lfendy">Liauw Fendy</a>.</p>
<p><a href="https://twitter.com/sidorares">@sidorares</a> is putting in a large amount of the legwork in to Melbourne&#39;s event. He was a major contributor to the original learnyounode and is a huge asset to the Melbourne Node community. Along with Andrey, Melbourne has large number of expert Node.js hackers, many of who will be available as mentors. This will be a treat for Melbournians so this is not something you should miss out on if you are in town! Potential mentors should contact Andrey.</p>
<p>You can <strong>sign up for Melbourne NodeSchool at <a href="https://ti.to/nodeschool/melbourne-june-2014/"><a href="https://ti.to/nodeschool/melbourne-june-2014/">https://ti.to/nodeschool/melbourne-june-2014/</a></a></strong>.</p>
<h2>NodeSchool in Hobart</h2>
<p>Hobart is lucky to have <a href="http://joshgilli.es/">@joshgillies</a>, a local tech-community organiser responsible for many Tasmanian web and JavaScript events. The event is being hosted at <a href="http://typewriterfactory.com/">The Typewriter Factory</a>, a business workspace that Josh helps run. Sponsorship is being provided by <a href="http://www.acs.org.au/">ACS</a> who will be helping support the venue and also provide some catering.</p>
<p>You can <strong>sign up for Hobart NodeSchool at <a href="https://ti.to/nodeschool/hobart-june-2014/"><a href="https://ti.to/nodeschool/hobart-june-2014/">https://ti.to/nodeschool/hobart-june-2014/</a></a></strong>.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="why-i-dont-use-nodes-core-stream-module"><a href="/2014/06/why-i-dont-use-nodes-core-stream-module.html">Why I don&#39;t use Node&#39;s core &#39;stream&#39; module</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on June 14, 2014</p>
        <p class="link"><a href="/2014/06/why-i-dont-use-nodes-core-stream-module.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2014/06/why-i-dont-use-nodes-core-stream-module.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p><em>This article was originally offered to nearForm for publishing and appeared for some time on their blog from early 2014 (at this URL: <a href="http://www.nearform.com/nodecrunch/dont-use-nodes-core-stream-module">http://www.nearform.com/nodecrunch/dont-use-nodes-core-stream-module</a>). It has since been deleted. I&#39;d rather not speculate about the reasons for the deletion but I believe the article contains a very important core message so I&#39;m now republishing it here.</em></p>
<h2>TL;DR</h2>
<p>The &quot;readable-stream&quot; package available in npm is a mirror of the Streams2 and Streams3 implementations in Node-core. You can guarantee a stable streams base, regardless of what version of Node you are using, if you only use &quot;readable-stream&quot;.</p>
<h2>The good &#39;ol days</h2>
<p>Prior to Node 0.10, implementing a stream meant extending the core <code>Stream</code> object. This object was simply an <code>EventEmitter</code> that added a special <code>pipe()</code> method to do the streaming magic.</p>
<p>Implementing a stream usually started with something like this:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Stream</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;stream&#39;</span><span class="p">).</span><span class="nx">Stream</span>
<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">)</span>

<span class="kd">function</span> <span class="nx">MyStream</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">MyStream</span><span class="p">,</span> <span class="nx">Stream</span><span class="p">)</span>

<span class="c1">// stream logic, implemented however you want</span>
</pre></div>

<p>If you ever had to write a non-trivial stream implementation for pre-Node 0.10 without using a helper library (such as <a href="https://github.com/dominictarr/through">through</a>), you know what a nightmare the state-management it can be. The actual implementation of a custom stream is a lot more than just the above code.</p>
<h2>Welcome to Node 0.10</h2>
<p>Thankfully, Streams2 came along with a brand new set of base Stream implementations that do a whole lot more than <code>pipe()</code>. The biggest win for stream implementers comes from the fact that state-management is almost entirely taken care of for you. You simply need to provide concrete implementations of some abstract methods to make a fully functional stream, even for non-trivial workloads.</p>
<p>Implementing a stream now looks something like this:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;stream&#39;</span><span class="p">).</span><span class="nx">Readable</span>
<span class="c1">// `Stream` is still provided for backward-compatibility</span>
<span class="c1">// Use `Writable`, `Duplex` and `Transform` where required</span>
<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">)</span>

<span class="kd">function</span> <span class="nx">MyStream</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">Readable</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span> <span class="cm">/* options, maybe `objectMode:true` */</span> <span class="p">})</span>
<span class="p">}</span>

<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">MyStream</span><span class="p">,</span> <span class="nx">Readable</span><span class="p">)</span>

<span class="c1">// stream logic, implemented mainly by providing concrete method implementations:</span>

<span class="nx">MyStream</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... </span>
<span class="p">}</span>
</pre></div>

<p>State-management is handled by the base-object and you interact with internal methods, such as <code>this.push(chunk)</code> in the case of a <code>Readable</code> stream.</p>
<p>While the internal streams implementations are an order-of-magnitude more complex than the previous core-streams implementation, most of it is there to make life an order-of-magnitude easier for those of us implementing custom streams. Yay!</p>
<h2>Backward-compatibility</h2>
<p>When every new major stable release of Node occurs, anyone releasing public packages in npm has to make a decision about which versions of Node they support. As a general rule, the authors of the most popular packages in npm will support the current stable version of Node and the previous stable release.</p>
<p>Streams2 was designed with backwards-compatibility in mind. Streams using <code>require(&#39;stream&#39;).Stream</code> as a base will still mostly work as you&#39;d expect and they will also work when piped to streams that extend the other classes. Streams2 streams won&#39;t work like classic EventEmitter objects when you pipe them together, as old-style streams do. But when you pipe a Streams2 stream and an old-style EventEmitter-based stream together, Streams2 will fall-back to &quot;compatibility-mode&quot; and operate in a backward-compatible way.</p>
<p>So Streams2 are great and mostly backward-compatible (aside from some tricky edge cases). But what about when you want to implement Streams2 and run on Node 0.8? And what about open source packages in npm that want to still offer Node 0.8 compatibility while embracing the new Streams2-goodness?</p>
<h3>&quot;readable-stream&quot; to the rescue</h3>
<p>During the 0.9 development phase, prior to the 0.10 release, Isaac developed the new Streams2 implementation in a package that was released in npm and usable on older versions of Node. The <a href="https://github.com/isaacs/readable-stream">readable-stream</a> package is essentially a mirror of the streams implementation of Node-core but is available in npm. This is a pattern we will hopefully be seeing more of as we march towards Node 1.0. Already there is a <a href="https://github.com/isaacs/core-util-is">core-util-is</a> package that makes available the shiny new <code>is</code> type-checking functions in the 0.11 core &#39;util&#39; package.</p>
<p><strong>readable-stream</strong> gives us the ability to use Streams2 on versions of Node that don&#39;t even have Streams2 in core. So a common pattern for supporting older versions of Node while still being able to hop on the Streams2-bandwagon starts off something like this, assuming you have &quot;readable-stream&quot; as a dependency:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;stream&#39;</span><span class="p">).</span><span class="nx">Readable</span> <span class="o">||</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;readable-stream&#39;</span><span class="p">).</span><span class="nx">Readable</span>
</pre></div>

<p>This works because there is no <code>Readable</code> object on the core &#39;stream&#39; package in 0.8 and prior, so if you are running on an older version of Node it skips straight to the &quot;readable-stream&quot; package to get the required implementation.</p>
<h2>Streams3: a new flavour</h2>
<p>The <strong>readable-stream</strong> package is still being used to track the changes to streams coming in 0.12. The upcoming Streams3 implementation is more of a tweak than a major change. It contains an attempt to make &quot;compatibility mode&quot; more of a first-class citizen of the API and also some improvements to pause/resume behaviour.</p>
<p>Like Streams2, the aim with Streams3 is for backward (and forward) compatibility but there are limits to what can be achieved on this front.</p>
<p>While this new streams implementation will likely be an improvement over the current Streams2 implementation, it is part of the <em>unstable</em> development branch of Node and is so far not 
without its edge cases which can break code designed against the pure 0.10 versions of Streams2.</p>
<h2>What is your base implementation?</h2>
<p>Looking back at the code used to fetch the base Streams2 implementation for building custom streams, let&#39;s consider what we&#39;re actually getting with different versions of Node:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;stream&#39;</span><span class="p">).</span><span class="nx">Readable</span> <span class="o">||</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;readable-stream&#39;</span><span class="p">).</span><span class="nx">Readable</span>
</pre></div>

<ul>
<li><em>Node 0.8 and prior:</em> we get whatever is provided by the readable-stream package in our dependencies.</li>
<li><em>Node 0.10:</em> we get the particular version of Streams2 that comes with the version of Node we&#39;re using.</li>
<li><em>Node 0.11:</em> we get the particular version of Streams3 that comes with the version of Node we&#39;re using.</li>
</ul>
<p>This may not be interesting if you have full control over all deployments of your custom stream implementations and which version(s) of Node they will be used on. But it can cause some problems in the case of open source libraries distributed via npm with users still stuck on 0.8 (for some, the upgrade path is not an easy one for various reasons), 0.10 and even people trying out some of the new Node and V8 features available in 0.11.</p>
<p>What you end up with is a very unstable base upon which to build your streams implementation. This is particularly acute since the vast bulk of the code used to construct the stream logic is coming from either Node-core or the readable-stream package. Any <em>bugs</em> fixed in later Node 0.10 releases will obviously still be present for people still stuck on earlier 0.10 releases even if the readable-stream dependency has the <em>fixed</em> version.</p>
<p>Then, when your streams code is run on Node 0.11, suddenly it&#39;s a Streams3 stream which has slightly different behaviour to what most of your users are experiencing.</p>
<p>One of the ways these subtle differences are exposed is in bug reports. Users may report a bug that only occurs on their particular combination of core-streams and readable-stream and it may not be obvious that the problem is related to base-stream implementation edge-cases they are stumbling upon; wasting time for everyone.</p>
<p>And what about stability? The fragmentation introduced by all of the possible combinations means that your otherwise stable library is having instability foisted upon it from the outside. This is one of the costs of relying on a featureful standard-library (core) within a rapidly developing, pre-v1 platform. But we can do something about it by taking control of the exact version of the base streams objects we want to extend regardless of what is bundled in the version of Node being used. <strong>readable-stream</strong> to the rescue!</p>
<h2>Taking control</h2>
<p>To control exactly what code your streams implementation is building on, simply pin the version of readable-stream and use only it, avoiding <code>require(&#39;stream&#39;)</code> completely. Then you get to make the choice when to upgrade to Streams3, even if that&#39;s some time <em>after</em> Node 0.12.</p>
<p><strong>readable-stream</strong> comes in two major versions, <strong>v1.0.x</strong> and <strong>v1.1.x</strong>. The former tracks the Streams2 implementation in Node 0.10, including bug-fixes and minor improvements as they are added. The latter tracks Streams3 as it develops in Node 0.11; we may see a v1.2.x branch for Node 0.12.</p>
<p>Any library worth using should be following the basics of semver minor and patch versions (the merits and finer points of major versioning are still something worth debating). readable-stream gives you proper patch-level versioning so if you pin to <code>&quot;~1.0.0&quot;</code> you&#39;ll get the latest Node 0.10 Streams2 implementation, including any fixes and minor non-breaking improvements. The patch-level version of 1.0.x and 1.1.x should mirror the patch-level versions of Node core releases as we proceed.</p>
<p>When you&#39;re ready to start using Streams3 you can pin to <code>&quot;~1.1.0&quot;</code>, but you should hold off until much closer to Node 0.12, if not after its formal release.</p>
<h2>Small core FTW!</h2>
<p>Being able to control precisely the versions of dependencies your code uses reduces the scope for bugs introduced by version incompatibilities or new and unproven implementations.</p>
<p>When we rely on a bulky standard-library to build our libraries and applications, we&#39;re relying on a shifting sand that we have little control over. This is particularly a problem for open source libraries whose users have legitimate (and sometimes not-so-legitimate) reasons for using versions that you&#39;d rather not have to support.</p>
<p>Streams2 is a powerful abstraction, but the implementation is far from simple. The Streams2 code is some of the most complex JavaScript you&#39;ll find in Node core. Unless you want to have a detailed understanding of how they work and be able to track the changes as they develop, you should pin your Streams2 dependency in the same way as you pin all your other dependencies. Opt for <strong>readable-stream</strong> over what Node-core offers:</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;mystream&quot;</span><span class="p">,</span>
  <span class="err">...</span>
  <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;readable-stream&quot;</span><span class="p">:</span> <span class="s2">&quot;~1.0.0&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;readable-stream&#39;</span><span class="p">).</span><span class="nx">Readable</span>
<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">)</span>

<span class="kd">function</span> <span class="nx">MyStream</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">Readable</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">MyStream</span><span class="p">,</span> <span class="nx">Readable</span><span class="p">)</span>

<span class="nx">MyStream</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... </span>
<span class="p">}</span>
</pre></div>

<h2>Addendum: &quot;through2&quot;</h2>
<p>If the boilerplate of the Streams2 base objects (&quot;classes&quot;) is too much for you or triggers some past-life Java PTSD, you can just opt for the &quot;through2&quot; package in npm to get the job done.</p>
<p><a href="https://github.com/rvagg/through2">through2</a> is based on Dominic Tarr&#39;s <a href="https://github.com/dominictarr/through">through</a> but is built for Streams2, whereas &quot;through&quot; is a pure Streams1 style. The API isn&#39;t quite the same but the flexibility and simplicity is.</p>
<p>through2 gives you a <code>DuplexStream</code> as a base to implement any kind of stream you like, be it as purely readable, purely writable or a fully duplex stream. In fact, you can even use through2 to implement a <code>PassThrough</code> stream by not providing an implementation!</p>
<p>From the examples:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">through2</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;through2&#39;</span><span class="p">)</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">&#39;ex.txt&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">through2</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">enc</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">97</span><span class="p">)</span>
        <span class="nx">chunk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">122</span> <span class="c1">// swap &#39;a&#39; for &#39;z&#39;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">)</span>

    <span class="nx">callback</span><span class="p">()</span>

   <span class="p">}))</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="s1">&#39;out.txt&#39;</span><span class="p">))</span>
</pre></div>

<p>Or an object stream:</p>
<div class="highlight"><pre><span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">&#39;data.csv&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">csv2</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">through2</span><span class="p">.</span><span class="nx">obj</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">enc</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">name</span>    <span class="o">:</span> <span class="nx">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">address</span> <span class="o">:</span> <span class="nx">chunk</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">phone</span>   <span class="o">:</span> <span class="nx">chunk</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="nx">callback</span><span class="p">()</span>

  <span class="p">}))</span>
  <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">all</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">doSomethingSpecial</span><span class="p">(</span><span class="nx">all</span><span class="p">)</span>
  <span class="p">})</span>
</pre></div>


      </section>

    </section>

  

    <section class="post-content">

      <h2 id="testing-code-against-many-node-versions-with-docker"><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html">Testing code against many Node versions with Docker</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on November 26, 2013</p>
        <p class="link"><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>I haven&#39;t found reason to play with <a href="http://www.docker.io">Docker</a> until now, but I&#39;ve finally came up with an excellent use-case.</p>
<p><a href="https://github.com/rvagg/nan">NAN</a> is a project that helps build native Node.js add-ons while maintaining compatibility with Node and V8 from Node versions 0.8 onwards. V8 is currently undergoing major internal changes which is making add-on development very difficult; NAN&#39;s purpose is to abstract that pain. Instead of having to manage the difficulties of keeping your code compatible across Node/V8 versions, NAN does it for you. But this means that we have to be sure to keep NAN tested and compatible with all of the versions it claims to support.</p>
<p><a href="https://travis-ci.org/">Travis</a> can help a little with this. It&#39;s possible to use <a href="https://github.com/creationix/nvm">nvm</a> to test across different versions of Node, we&#39;ve tried this with NAN (see the <a href="https://github.com/rvagg/nan/blob/ba82a9c1fba01b3df553ac624aeaf15ca3688315/.travis.yml">.travis.yml</a>). Ideally you&#39;d have better choice of Node versions, but Travis have had some <a href="https://github.com/travis-ci/travis-ci/issues/1328">difficulty</a> keeping up. Also, npm bugs make it difficult, with a high failure rate from npm install problems, like <a href="https://travis-ci.org/rvagg/nan/jobs/14440485">this</a> and <a href="https://travis-ci.org/rvagg/nan/jobs/14474613">this</a>, so I don&#39;t even publish the badge on the NAN README.</p>
<p>The other problem with Travis is that it&#39;s a CI solution, not a proper testing solution. Even if it worked well, it&#39;s not really that helpful in the development process, you need rapid feedback that your code is working on your target platforms (this is one reason why I love back-end development more than front-end development!)</p>
<p>Enter Docker and <strong><a href="https://github.com/rvagg/dnt">DNT</a></strong></p>
<div style="margin: 0 auto;">
  <img src="http://www.docker.io/static/img/homepage-docker-logo.png" width="138" height="114">
  <img src="http://nodejs.org/images/logos/nodejs-dark.png" width="212" height="114">
  <img src="http://img.pandawhale.com/29490-Picard-applause-clapping-gif-s5nz.gif" width="151" height="114">
</div>

<h3>DNT: Docker Node Tester</h3>
<p>Docker is a tool that simplifies the use of Linux containers to create lightweight, isolated compute &quot;instances&quot;. Solaris and its variants have had this functionality for years in the form of &quot;zones&quot; but it&#39;s a fairly new concept for Linux and Docker makes the whole process a lot more friendly.</p>
<p><strong>DNT</strong> contains two tools that work with Docker and Node.js to set-up containers for testing and run your project&#39;s tests in those containers.</p>
<div style="margin: 0 auto;">
  <img src="http://r.va.gg/images/2013/11/nan-dnt.png">
</div>

<p><strong>DNT</strong> includes a <code>setup-dnt</code> script that sets up the most basic Docker images required to run Node.js applications, nothing extra. It first creates an image called &quot;dev_base&quot; that uses the default Docker &quot;ubuntu&quot; image and adds the build tools required to compile and install Node.js</p>
<p>Next it creates a &quot;node_dev&quot; image that contains a complete copy of the Node.js <a href="http://github.com/joyent/node">source repository</a>. Finally, it creates a series of images that are required; for each Node version, it creates an image with Node installed and ready to use.</p>
<p>Setting up a project is a matter of creating a <em>.dntrc</em> file in the root directory of the project. This configuration file involves setting a <code>NODE_VERSIONS</code> variable with a list of all of the versions of Node you want to test against, and this can include &quot;master&quot; to test the latest code from the Node repository. You also set a <code>TEST_CMD</code> variable with a series of commands required to set up, compile and execute your tests. The <code>setup-dnt</code> command can be run against a <em>.dntrc</em> file to make sure that the appropriate Docker images are ready. The <code>dnt</code> command can then be used to execute the tests against all of the Node versions you specified.</p>
<p>Since Docker containers are completely isolated, <strong>DNT</strong> can run tests in parallel as long as the machine has the resources. The default is to use the number of cores on the computer as the concurrency level but this can be configured if not appropriate.</p>
<p>Currently <strong>DNT</strong> is designed to parse TAP test output by reading the final line as either &quot;ok&quot; or &quot;not ok&quot; to report test status back on the command-line. It is configurable but you need to supply a command that will transform test output to either an &quot;ok&quot; or &quot;not ok&quot; (<code>sed</code> to the rescue?).</p>
<h3>How I&#39;m using it</h3>
<p>My primary use-case is for testing <strong>NAN</strong>. The test suite needs a lot of work so being able to test against all the different V8 and Node APIs while coding is super helpful; particularly when tests run so quickly! My NAN <em>.dntrc</em> file tests against master, all of the 0.11 releases since 0.11.4 (0.11.0 to 0.11.3 are explicitly not supported by NAN) and the last 5 releases of the 0.10 and 0.8 series. At the moment that&#39;s 17 versions of Node in all and on my computer the test suite takes approximately 20 seconds to complete across all of these releases.</p>
<p><strong>The NAN <a href="https://raw.github.com/rvagg/nan/master/.dntrc">.dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  master   \</span>
<span class="s2">  v0.11.9  \</span>
<span class="s2">  v0.11.8  \</span>
<span class="s2">  v0.11.7  \</span>
<span class="s2">  v0.11.6  \</span>
<span class="s2">  v0.11.5  \</span>
<span class="s2">  v0.11.4  \</span>
<span class="s2">  v0.10.22 \</span>
<span class="s2">  v0.10.21 \</span>
<span class="s2">  v0.10.20 \</span>
<span class="s2">  v0.10.19 \</span>
<span class="s2">  v0.10.18 \</span>
<span class="s2">  v0.8.26  \</span>
<span class="s2">  v0.8.25  \</span>
<span class="s2">  v0.8.24  \</span>
<span class="s2">  v0.8.23  \</span>
<span class="s2">  v0.8.22  \</span>
<span class="s2">&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;nan-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  cd /dnt/test/ &amp;&amp;                                               \</span>
<span class="s2">  npm install &amp;&amp;                                                 \</span>
<span class="s2">  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild &amp;&amp; \</span>
<span class="s2">  node_modules/.bin/tap js/*-test.js;                            \</span>
<span class="s2">&quot;</span>
</pre></div>

<p>Next I configured <strong><a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a></strong> for <strong>DNT</strong>. The needs are much simpler, the tests need to do a compile and run a lot of node-tap tests.</p>
<p><strong>The LevelDOWN <a href="https://raw.github.com/rvagg/node-leveldown/master/.dntrc">.dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  master   \</span>
<span class="s2">  v0.11.9  \</span>
<span class="s2">  v0.11.8  \</span>
<span class="s2">  v0.10.22 \</span>
<span class="s2">  v0.10.21 \</span>
<span class="s2">  v0.8.26  \</span>
<span class="s2">&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;leveldown-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  cd /dnt/ &amp;&amp;                                                    \</span>
<span class="s2">  npm install &amp;&amp;                                                 \</span>
<span class="s2">  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild &amp;&amp; \</span>
<span class="s2">  node_modules/.bin/tap test/*-test.js;                          \</span>
<span class="s2">&quot;</span>
</pre></div>

<p>Another native Node add-on that I&#39;ve set up with <strong>DNT</strong> is my <a href="https://github.com/rvagg/node-libssh">libssh bindings</a>. This one is a little more complicated because you need to have some non-standard libraries installed before compile. My <em>.dntrc</em> adds some extra <code>apt-get</code> sauce to fetch and install those packages. It means the tests take a little longer but it&#39;s not prohibitive. An alternative would be to configure the <em>node_dev</em> base-image to have these packages to all of my versioned images have them too.</p>
<p><strong>The node-libssh <a href="https://raw.github.com/rvagg/node-libssh/master/.dntrc">.dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;master v0.11.9 v0.10.22&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;libssh-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  apt-get install -y libkrb5-dev libssl-dev &amp;&amp;                           \</span>
<span class="s2">  cd /dnt/ &amp;&amp;                                                            \</span>
<span class="s2">  npm install &amp;&amp;                                                         \</span>
<span class="s2">  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild --debug &amp;&amp; \</span>
<span class="s2">  node_modules/.bin/tap test/*-test.js --stderr;                         \</span>
<span class="s2">&quot;</span>
</pre></div>

<p><a href="https://github.com/rvagg/node-levelup">LevelUP</a> isn&#39;t a native add-on but it does use LevelDOWN which requires compiling. For the DNT config I&#39;m removing <em>node_modules/leveldown/</em> prior to <code>npm install</code> so it gets rebuilt each time for each new version of Node.</p>
<p><strong>The <a href="https://raw.github.com/rvagg/node-levelup/master/.dntrc">LevelUP .dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  master   \</span>
<span class="s2">  v0.11.9  \</span>
<span class="s2">  v0.11.8  \</span>
<span class="s2">  v0.10.22 \</span>
<span class="s2">  v0.10.21 \</span>
<span class="s2">  v0.8.26  \</span>
<span class="s2">&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;levelup-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  cd /dnt/ &amp;&amp;                                                    \</span>
<span class="s2">  rm -rf node_modules/leveldown/ &amp;&amp;                              \</span>
<span class="s2">  npm install --nodedir=/usr/src/node &amp;&amp;                         \</span>
<span class="s2">  node_modules/.bin/tap test/*-test.js --stderr;                 \</span>
<span class="s2">#&quot;</span>
</pre></div>

<h3>What&#39;s next?</h3>
<p>I have no idea but I&#39;d love to have helpers flesh this out a little more. It&#39;s not hard to imagine this forming the basis of a local CI system as well as a general testing tool. The speed even makes it tempting to run the tests on every git commit, or perhaps on every save.</p>
<p>If you&#39;d like to contribute to development then please submit a pull request, I&#39;d be happy to discuss anything you might think would improve this project. I&#39;m keen to share ownership with anyone making significant contributions; as I do with most of my open source projects.</p>
<p>See the <strong><a href="https://github.com/rvagg/dnt">DNT</a></strong> GitHub repo for installation and detailed usage instructions.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="leveldown-v0.10-managing-gc-in-native-v8-programming"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">LevelDOWN v0.10 / managing GC in native V8 programming</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on November 18, 2013</p>
        <p class="link"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p><img src="https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png" alt="LevelDB"></p>
<p>Today we released version 0.10 of <a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a>. LevelDOWN is the package that directly binds LevelDB into Node-land. It&#39;s mainly C++ and is a fairly raw &amp; direct interface to LevelDB. <a href="https://github.com/rvagg/node-levelup">LevelUP</a> is the package that we recommend most people use for LevelDB in Node as it takes LevelDOWN and makes it much more Node-friendly, including the addition of those lovely <em>ReadStreams</em>.</p>
<p>Normally I wouldn&#39;t write a post about a minor release like this but this one seems significant because of a number of small changes that culminate in a <em>relatively</em> major release.</p>
<p><strong><em>In this post:</em></strong></p>
<ul>
<li><strong>V8 <code>Persistent</code> references</strong></li>
<li><strong><code>Persistent</code> in LevelDOWN; some removed, some added</strong></li>
<li><strong>Leaks!</strong></li>
<li><strong>Snappy 1.1.1</strong></li>
<li><strong>Some embarrassing bugs</strong></li>
<li><strong>Domains</strong></li>
<li><strong>Summary</strong></li>
<li><strong><em>A final note on Node 0.11.9</em></strong></li>
</ul>
<h3>V8 <code>Persistent</code> references</h3>
<p>The main story of this release are <code>v8::Persistent</code> references. For the uninitiated, V8 internally has two different ways to track &quot;handles&quot;, which are references to JavaScript objects and values currently active in a running program. There are <code>Local</code> references and there are <code>Persistent</code> references. <code>Local</code> references are the most common, they are the references you get when you create an object or pass them around within a function and do the normal work that you do with an object. <code>Persistent</code> references are a special case that is all about <em>Garbage Collection</em>. An object that has at least one active <code>Persistent</code> reference to it is not a candidate for garbage collection. <code>Persistent</code> references must be explicitly destroyed before they release the object and make it available to the garbage collector.</p>
<p>Prior to V8 3.2x.xx <em>(I don&#39;t know the exact version, does it matter? It roughly corresponds to Node v0.11.3.)</em>, these handles were both as easy as each other to create and interchange. You could swap one for the other whenever you needed. My guess is that the V8 team decided that this was a little <em>too</em> easy and that a major cause for memory leaks in C++ V8 code was the ease at which you could swap a <code>Local</code> for a <code>Persistent</code> and then forget to destroy the <code>Persistent</code>. So they tweaked the &quot;ease&quot; equation and it&#39;s become quite difficult.</p>
<p><code>Persistent</code> and <code>Local</code> no longer share the same type hierarchy and the way you instantiate and assign a <code>Persistent</code> has become quite awkward. You now have to go through enough gymnastics to create a <code>Persistent</code> that it makes you ask the question: <em>&quot;Do I really need this to be a <code>Persistent</code>?&quot;</em> Which I guess is a good thing for memory leaks. <a href="https://github.com/rvagg/nan">NAN</a> to the rescue though! We&#39;ve somewhat papered over those difficulties with the capabilities introduced in NAN, it&#39;s still not as easy as it once was but it&#39;s not a total headache.</p>
<p>So, you understand <code>v8::Persistent</code> now? Great, so back to LevelDOWN.</p>
<h3><code>Persistent</code> in LevelDOWN; some removed, some added!</h3>
<p><strong>Some removed</strong></p>
<p>Recently, <a href="https://github.com/mcollina">Matteo</a> noticed that when you&#39;re performing a <code>Batch()</code> operation in LevelDB, there is an explicit copy of the data that you&#39;re feeding in to that batch. When you construct a Batch operation in LevelDB you start off with a short string representing the batch and then build on that string as you build your batch with both <code>Put()</code> and <code>Del()</code> operations. You end up with a long string containing all of your write data; keys and values. Then when you call <code>Write()</code> on the Batch, that string gets fed directly into the main LevelDB store as a single write&mdash;which is where the atomicity of Batch comes from.</p>
<p>Both the chained-form and array-form <code>batch()</code> operations work this way internally in LevelDOWN.</p>
<p>However, with almost all operations in LevelDOWN, we perform the actual writes and reads against LevelDB in libuv worker threads. So we have to create the &quot;descriptor&quot; for work in the main V8 Node thread and then hand that off to libuv to perform the work in a separate thread. Once the work is completed we get the results back in the main V8 Node thread from where we can trigger a callback. This is where <code>Persistent</code> references come in.</p>
<p>Before we hand off the work to libuv, we need to make <code>Persistent</code> references to any V8 object that we want to survive across the asynchronous operation. Obviously the main candidate for this is <code>callback</code> functions. Consider this code:</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo = %s&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>

<p>What we&#39;ve actually done is create an anonymous closure for our callback. It has nothing referencing it, so as far as V8 is concerned it&#39;s a candidate for garbage collection once the current thread of execution is completed. In Node however, we&#39;re doing asynchronous work with it and need it to survive until we actually call it. This is where <code>Persistent</code> references come in. We receive the <code>callback</code> function as a <code>Local</code> in our C++ but then assign it to a <code>Persistent</code> so GC doesn&#39;t touch it. Once we&#39;re done our async work we can call the function and destroy the <code>Persistent</code>, effectively turning it back in to a <code>Local</code> and freeing it up for GC.</p>
<p>Without the <code>Persistent</code> then the behaviour is indeterminate. It depends on the version of V8, the GC settings, the workload currently in the program and the amount of time the async work takes to complete. If the GC is aggressive enough and has a chance to run before our async work is complete, the <code>callback</code> will disappear and we&#39;ll end up trying to call a function that no longer exists. This can obviously lead to runtime errors and will most likely crash our program.</p>
<p>In LevelDOWN, if you&#39;re passing in <code>String</code> objects for keys and values then to pull out the data and turn it in to a form that LevelDB can use we have to do an explicit <em>copy</em>. Once we&#39;ve copied the data from the <code>String</code> then we don&#39;t need to care about the original object and GC can get its hands on it as soon as it wants. So we can leave <code>String</code> objects as <code>Local</code> references while we are building the descriptor for our async work.</p>
<p><code>Buffer</code> objects are a different matter all together. Because we have access to the raw character array of a <code>Buffer</code>, we can feed that data straight in to LevelDB and this will save us one <em>copy</em> operation (which can be a significant performance boost if the data is significantly large or you&#39;re doing lots of operations&mdash;so prefer <code>Buffer</code>s where convenient if you need higher perf). When building the descriptor for the async work, we are just passing a character array to the LevelDB data structures that we&#39;re setting up. Because the data is shared with the original <code>Buffer</code> we have to make sure that GC doesn&#39;t clean up that <code>Buffer</code> before we have a chance to use the data. So we make a <code>Persistent</code> reference for it which we clean up after the async work is complete. So you can do this without worrying about GC:</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">).</span><span class="nx">randomBytes</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
  <span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo is now some random data!&#39;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>

<p>This has been the case in LevelDOWN for all operations since pretty much the beginning. But back to Matteo&#39;s observation. If LevelDB&#39;s data structures perform an explicit copy on the data we feed it then perhaps we don&#39;t need to keep the original data safe from GC? For a <code>batch()</code> call it turns out that we don&#39;t! When we&#39;re constructing the Batch descriptor, as we feed in data to it, both <code>Put()</code> and <code>Del()</code>, it&#39;s taking a copy of our data to create its internal representation. So even when we&#39;re using <code>Buffer</code> objects on the JavaScript side, we&#39;re done with them before the call down in to LevelDOWN is completed so there&#39;s no reason to save a <code>Persistent</code> reference! For other operations we&#39;re still doing some copying during the asynchronous cycle but the removal of the overhead of creating and deleting <code>Persistent</code> references for <code>batch()</code> calls is fantastic news for those doing bulk data loading (like Max Ogden&#39;s <a href="https://github.com/maxogden/dat">dat</a> project which needs to bulk load a <em>lot</em> of data).</p>
<p><strong>Some added</strong></p>
<p>Another gem from Matteo was reports of crashes during certain <code>batch()</code> operations. Difficult to reproduce and only under very particular circumstances, it seems to be mostly reproducible by the kinds of workloads generated by LevelGraph. Thanks to some simple C++ debugging we traced it to a dropped reference, obviously by GC. The code in question boiled down to something like this:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">doStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>In this code, the <code>batch</code> object is actually a LevelDOWN <code>Batch</code> object created in C++-land. During the <code>write()</code> operation, which is asynchronous, we end up with no hard references to <code>batch</code> in our code because the JS thread has yieled and moved on and the <code>batch</code> is contained within the scope of the <code>doStuff()</code> function. Because most of the asynchronous operations we perform are relatively quick, this normally doesn&#39;t matter. But for writes to LevelDB, if you have enough data in your write and you have enough data already in your data store, you can trigger a compaction upstream which can delay the write which can give V8&#39;s GC time to clean up references that might be important and for which you have no <code>Persistent</code> handles.</p>
<p>In this case, we weren&#39;t actually creating internal <code>Persistent</code> references for some of our objects. <code>Batch</code> in this case but also <code>Iterator</code>. Normally this isn&#39;t a problem because to use these objects you <em>generally</em> keep references to them yourself in your own code.</p>
<p>We managed to debug Matteo&#39;s crash by adjusting his test code to look something like this and watching it succeed without a crash:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">doStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">batch</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>By reusing <code>batch</code> inside our <code>callback</code> function, we&#39;re creating some work that V8 can&#39;t optimise away and therefore has to assume isn&#39;t a noop. Because the <code>batch</code> variable is also now referenced by the <code>callback</code> function and we already have an internal <code>Persistent</code> for it, GC has to pass over <code>batch</code> until the <code>Persistent</code> is destroyed for the <code>callback</code>.</p>
<p>So the solution is simply to create a <code>Persistent</code> for the internal objects that need to survive across asynchronous operations and make no assumptions about how they&#39;ll be used in JavaScript-land. In our case we&#39;ve gone for assigning a <code>Persistent</code> just prior to every asynchronous operation and destroying it after. The alternative would be to have a <code>Persistent</code> assigned upon the creation of objects we care about but sometimes we want GC to do its work:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">dontDoStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="c1">// nothing else, wut?</span>
<span class="p">}</span>
</pre></div>

<p>I don&#39;t know why you would write that code but perhaps you have a use-case where you want the ability to start constructing a batch but then decide not to follow through with it. GC should be able to take care of your mess like it does with all of the other messes you create in your daily adventures with JavaScript.</p>
<p>So we are only assigning a <code>Persistent</code> when you do a <code>write()</code> with a chained-batch operation in LevelDOWN since it&#39;s the only asynchronous operation. So in <code>dontDoStuff()</code> GC will come along and rid us of <code>batch</code>, <code>&#39;foo&#39;</code> and <code>&#39;bar&#39;</code> when it has the next opportunity and our C++ code will have the appropriate destructors called that will clean up any other objects we have created along the way, like the internal LevelDB <code>Batch</code> with its copy of our data.</p>
<h3>Leaks!</h3>
<p>We&#39;ve been having some trouble with leaks in LevelUP/LevelDOWN lately <em>(<a href="https://github.com/rvagg/node-levelup/issues/171">LevelDOWN/#171</a>, <a href="https://github.com/mcollina/levelgraph/issues/40">LevelGraph/#40</a>)</em>. And it turns out that these leaks aren&#39;t related to <code>Persistent</code> references, which shouldn&#39;t be a surprise since it&#39;s so easy to leak with non-GC code, particularly if you spend most of your day programming in a language with GC.</p>
<p>With the help of <a href="http://valgrind.org/">Valgrind</a> we tracked the leak down to the omission of a <code>delete</code> in the destructor of the asynchronous work descriptor for array-batch operations. The internal LevelDB representation of a Batch wasn&#39;t being cleaned up unless you were using the chained-form of LevelDOWN&#39;s <code>batch()</code>. This one has been dogging us for a few releases now and it&#39;s been a headache particularly for people doing bulk-loading of data so I hope we can finally put it behind us!</p>
<h3>Snappy 1.1.1</h3>
<p>Google released a new version of Snappy, version 1.1.1. I don&#39;t really understand how Google uses <a href="http://semver.org/">semver</a>; we get very simple LevelDB releases with the minor version bumped and then we get versions of Snappy released with non-trivial changes with only the patch version bumped. I suspect that Google doesn&#39;t know how it uses semver either and there&#39;s no internal policy on it.</p>
<p>Anyway, Snappy 1.1.1 has some fixes, some minor speed and compression improvements but most importantly it breaks compilation on Windows. So we had to figure out how to fix that for this release. Ugh. I also took the opportunity to clean up some of the compilation options for Snappy and we may see some improvements in the way it works now... perhaps.</p>
<h3>Some embarrassing bugs</h3>
<p><a href="https://github.com/Kyotoweb">Amine Mouafik</a> is new to the LevelDOWN repository but has picked up some rather embarrassing bugs/omissions that are probably my fault. It&#39;s great to have more eyes on the C++ code, there&#39;s not enough JavaScript programmers with the confidence to dig in to messy C++-land.</p>
<p>Firstly, on our standard LevelDOWN releases, it turns out that we haven&#39;t actually been enabling the internal <strong>bloom filter</strong>. The bloom filter was introduced in LevelDB to speed up read operations to avoid having to scan through whole blocks to find the data a read is looking for. So that&#39;s now enabled for 0.10.</p>
<p>Then he discovered that we had been <strong>turning off compression</strong> by default! I believe this happened with the the switch to NAN. The signature for reading boolean options from V8 objects was changed from internal <code>LD_BOOLEAN_OPTION_VALUE</code> &amp; <code>LD_BOOLEAN_OPTION_VALUE_DEFTRUE</code> macros for defaulting to true and false respectively when the options aren&#39;t supplied, to the NAN version which is a unified <code>NanBooleanOptionValue</code> which takes an optional <code>defaultValue</code> argument that can be used to make the default <code>true</code>. This happened at roughly Node version 0.11.4.</p>
<p>Well, this code:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">compression</span> <span class="o">=</span>
    <span class="n">NanBooleanOptionValue</span><span class="p">(</span><span class="n">optionsObj</span><span class="p">,</span> <span class="n">NanSymbol</span><span class="p">(</span><span class="s">&quot;compression&quot;</span><span class="p">));</span>
</pre></div>

<p>is now this:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">compression</span> <span class="o">=</span>
    <span class="n">NanBooleanOptionValue</span><span class="p">(</span><span class="n">optionsObj</span><span class="p">,</span> <span class="n">NanSymbol</span><span class="p">(</span><span class="s">&quot;compression&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
</pre></div>

<p>so if you don&#39;t supply a <code>&quot;compression&quot;</code> boolean option in your db setup operation then it&#39;ll now actually be turned on!</p>
<h3>Domains</h3>
<p>We&#39;ve finally caught up with properly supporting Node&#39;s <a href="http://nodejs.org/docs/latest/api/domain.html">domains</a> by switching all C++ <code>callback</code> calls from standard V8 <code>callback-&gt;Call(...)</code> to Node&#39;s own <code>node::MakeCallback(callback, ...)</code> which does the same thing but also does lots of additional things, including accounting for domains. This change was also included in NAN version 0.5.0.</p>
<h3>Summary</h3>
<p><strong>Go and upgrade!</strong></p>
<p>leveldown@0.10.0 is packaged with the new levelup@0.18.0 and level@0.18.0 which have their minor versions bumped purely for this LevelDOWN release.</p>
<p>Also released are the packages:</p>
<ul>
<li>leveldown-hyper@0.10.0</li>
<li>leveldown-basho@0.10.0</li>
<li>rocksdb@0.10.0 (based on the same LevelDOWN code) (Linux only)</li>
<li>level-hyper@0.18.0 (levelup on leveldown-hyper)</li>
<li>level-basho@0.18.0 (levelup on leveldown-basho)</li>
<li>level-rocks@0.18.0 (levelup on rocksdb) (Linux only)</li>
</ul>
<p>I&#39;ll write more about these packages in the future since they&#39;ve gone largely under the radar for most people. If you&#39;re interested in catching up then please join <strong>##leveldb</strong> on Freenode where there&#39;s a bunch of Node database people and also a few non-Node LevelDB people like <a href="https://twitter.com/rescrv">Robert Escriva</a>, author of HyperLevelDB and all-round LevelDB expert.</p>
<h3><em>A final note on Node 0.11.9</em></h3>
<p>There will be a LevelDOWN@0.10.1 very soon that will increment the NAN dependency to 0.6.0 when it&#39;s released. This new version of NAN will specifically deal with Node 0.11.9 compatibility where there are more breaking V8 changes that will cause compile errors for any addon not taking them in to account. So if you&#39;re living on the edge in Node then we should have a release soon enough for you!</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="all-the-levels"><a href="/2013/10/all-the-levels.html">All the levels!</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 9, 2013</p>
        <p class="link"><a href="/2013/10/all-the-levels.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/all-the-levels.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>When we completely separated <a href="https://github.com/rvagg/node-levelup">LevelUP</a> and <a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a> so that installing LevelUP didn&#39;t automatically get you LevelDOWN, we set up a new package called <strong><a href="https://github.com/Level/level">Level</a></strong> that has them both as a dependency so you just need to do <code>var level = require(&#39;level&#39;)</code> and everything is done for you.</p>
<p>But, we now have more than just the vanilla (Google) LevelDB in LevelDOWN. We also have a HyperLevelDB version and a Basho fork. These are maintained on branches in the LevelDOWN repo and are usually released now every time a new LevelDOWN is released. They are called <strong>leveldown-hyper</strong> and <strong>leveldown-basho</strong> in npm but you need to plug them in to LevelUP yourself to make them work. We also have <a href="https://github.com/rvagg/lmdb">Node LMDB</a> that&#39;s LevelDOWN compatible and a few others.</p>
<p>So, as of today, we&#39;ve released a new, small library called <strong><a href="https://github.com/level/level-packager">level-packager</a></strong> that does this bundling process so that you can feed it a LevelDOWN instance and it&#39;ll return a Level-type object that can be exported from a package like <strong>Level</strong>. This is meant to be used internally and it&#39;s now being used to support these new packages that are available in npm:</p>
<ul>
<li><strong><a href="https://github.com/Level/level-hyper">level-hyper</a></strong> bundles the HyperLevelDB version of LevelDOWN with LevelUP</li>
<li><strong><a href="https://github.com/Level/level-basho">level-basho</a></strong> bundles the Bash fork of LevelDB in LevelDOWN with LevelUP</li>
<li><strong><a href="https://github.com/Level/level-lmdb">level-lmdb</a></strong> bundles Node LMDB with LevelUP</li>
</ul>
<p>The version numbers of these packages will track the version of LevelUP.</p>
<p>So you can now simply do:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">level</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level-hyper&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">level</span><span class="p">(</span><span class="s1">&#39;/path/to/db&#39;</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;woohoo!&#39;</span><span class="p">)</span>
</pre></div>

<p>If you&#39;re already using <strong>Level</strong> then you can very easily switch it out with one of these alternatives to try them out.</p>
<p>Both HyperLevelDB and the Basho LevelDB fork are binary-compatible with Google&#39;s LevelDB, with one small caveat: with the latest release, LevelDB has switched to making <em>.ldb</em> files instead of <em>.sst</em> files inside a data store directory because of something about Windows backups (blah blah). Neither of the alternative forks know anything about these new files yet so you may run in to trouble if you have <em>.ldb</em> files in your store (although I&#39;m pretty sure you can simply rename these to <em>.sst</em> and it&#39;ll be fine with any version).</p>
<p>Also, LMDB is completely different to LevelDB so you won&#39;t be able to open an existing data store. But you should be able to do something like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">)(</span><span class="s1">&#39;/path/to/level.db&#39;</span><span class="p">).</span><span class="nx">createReadStream</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level-lmdb&#39;</span><span class="p">)(</span><span class="s1">&#39;/path/to/lmdb.db&#39;</span><span class="p">).</span><span class="nx">createWriteStream</span><span class="p">())</span>
</pre></div>

<p>Whoa...</p>
<h3>A note about HyperLevelDB</h3>
<p>Lastly, I&#39;d like to encourage you to try the HyperLevelDB version if you are pushing hard on LevelDB&#39;s performance. The HyperDex fork is tuned for multi-threaded access for reads and writes and is therefore particularly suited to how we use it in Node. The Basho version doesn&#39;t show much performance difference mainly because they are optimising for Riak running 16 separate instances on the same server so multi-threaded access isn&#39;t as interesting for them. You should find significant performance gains if you&#39;re doing very heavy writes in particular with HyperLevelDB. Also, if you&#39;re interested in support for HyperLevelDB then pop in to ##leveldb on Freenode and bother <em><a href="https://twitter.com/rescrv">rescrv</a></em> (Robert Escriva), author of HyperLevelDB and our resident LevelDB expert.</p>
<p>It&#39;s also worth nothing that HyperDex are interested in offering commercial support for people using LevelDB, not just HyperLevelDB but also Google&#39;s LevelDB. This means that anyone using either of these packages in Node should be able to get solid support if they are doing any heavy work in a commercial environment and need the surety of experts behind them to help pick up the pieces. I imagine this would cover things like LevelDB corruption and any LevelDB bugs you may run in to (we&#39;re currently looking at a subtle <a href="https://github.com/rvagg/node-levelup/issues/171">batch-related LevelDB bug</a> that&#39;s come along with the 1.14.0 release, they do exist!). Talk to Robert if you want more information about commercial support.</p>

      </section>

    </section>

  
</div>

  <section class="pager">
    
 

      <div class="next">
        <a href="/page1.html">&laquo; Older posts</a>
      </div>

    
  </section>
  <div style="clear: both;"></div>

  <!--
  <script type="text/javascript">
    var disqus_shortname = 'rvagg'

    !(function () {
      var s = document.createElement('script')
      s.async = true
      s.type = 'text/javascript'
      s.src = 'http://' + disqus_shortname + '.disqus.com/count.js'
      !(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s)
    }())
  </script>
  -->



      <section class="footer">
        &copy; Rod Vagg 2013, powered by <a href="https://github.com/rvagg/blorg">Blorg</a>
        <br><a href="http://r.va.gg/atom.xml">Atom / RSS feed</a>
      </section>

    </section>

  </body>
</html>