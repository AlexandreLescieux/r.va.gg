<!DOCTYPE HTML>
<html lang="en-us">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>r.va.gg</title>
    <link rel="stylesheet" href="/style.css" type="text/css">
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://r.va.gg/atom.xml" />
    <script type="text/javascript" src="http://use.typekit.com/swo4snt.js"></script>
    <script type="text/javascript">try{Typekit.load()}catch(e){}</script>  
    <script type="text/javascript">
      var _gaq = _gaq || []
      _gaq.push(['_setAccount', 'UA-21373682-1'])
      _gaq.push(['_trackPageview'])
      setTimeout('_gaq.push(["_trackEvent", "15_seconds", "read"])', 15000)
      !(function () {
        var ga = document.createElement('script')
        ga.type = 'text/javascript'
        ga.async = true
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'
        var s = document.getElementsByTagName('script')[0]
        s.parentNode.insertBefore(ga, s)
      }())
    </script>
  </head>
  <body>

    <section class="content">
      <h1>
        <a href="/">r.va.gg</a>
      </h1>

      <section class="nav">
        <section class="me">
          <span>Find me</span>
          <ul>
            <li>on <a href="https://twitter.com/rvagg">Twitter / @rvagg</a></li>
            <li>on <a href="https://github.com/rvagg">GitHub / @rvagg</a></li>
          </ul>
        </section>
        <section class="recent">
          <span>Recent posts</span>
          <ul>
            
 
                <li><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">LevelDOWN v0.10 / managing GC in native V8 programming</a></li>
              
 
 
                <li><a href="/2013/10/all-the-levels.html">All the levels!</a></li>
              
 
 
                <li><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html">Should I use a single LevelDB or many to hold my data?</a></li>
              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
          </ul>
        </section>
      </section>
      <div style="clear: both;"></div>

      

<div id="for">
  

    <section class="post-content">

      <h2 id="leveldown-v0.10-managing-gc-in-native-v8-programming"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">LevelDOWN v0.10 / managing GC in native V8 programming</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on November 18, 2013</p>
        <p class="link"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p><img src="https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png" alt="LevelDB"></p>
<p>Today we released version 0.10 of <a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a>. LevelDOWN is the package that directly binds LevelDB into Node-land. It&#39;s mainly C++ and is a fairly raw &amp; direct interface to LevelDB. <a href="https://github.com/rvagg/node-levelup">LevelUP</a> is the package that we recommend most people use for LevelDB in Node as it takes LevelDOWN and makes it much more Node-friendly, including the addition of those lovely <em>ReadStreams</em>.</p>
<p>Normally I wouldn&#39;t write a post about a minor release like this but this one seems significant because of a number of small changes that culminate in a <em>relatively</em> major release.</p>
<p><strong><em>In this post:</em></strong></p>
<ul>
<li><strong>V8 <code>Persistent</code> references</strong></li>
<li><strong><code>Persistent</code> in LevelDOWN; some removed, some added</strong></li>
<li><strong>Leaks!</strong></li>
<li><strong>Snappy 1.1.1</strong></li>
<li><strong>Some embarrassing bugs</strong></li>
<li><strong>Domains</strong></li>
<li><strong>Summary</strong></li>
<li><strong><em>A final note on Node 0.11.9</em></strong></li>
</ul>
<h3>V8 <code>Persistent</code> references</h3>
<p>The main story of this release are <code>v8::Persistent</code> references. For the uninitiated, V8 internally has two different ways to track &quot;handles&quot;, which are references to JavaScript objects and values currently active in a running program. There are <code>Local</code> references and there are <code>Persistent</code> references. <code>Local</code> references are the most common, they are the references you get when you create an object or pass them around within a function and do the normal work that you do with an object. <code>Persistent</code> references are a special case that is all about <em>Garbage Collection</em>. An object that has at least one active <code>Persistent</code> reference to it is not a candidate for garbage collection. <code>Persistent</code> references must be explicitly destroyed before they release the object and make it available to the garbage collector.</p>
<p>Prior to V8 3.2x.xx <em>(I don&#39;t know the exact version, does it matter? It roughly corresponds to Node v0.11.3.)</em>, these handles were both as easy as each other to create and interchange. You could swap one for the other whenever you needed. My guess is that the V8 team decided that this was a little <em>too</em> easy and that a major cause for memory leaks in C++ V8 code was the ease at which you could swap a <code>Local</code> for a <code>Persistent</code> and then forget to destroy the <code>Persistent</code>. So they tweaked the &quot;ease&quot; equation and it&#39;s become quite difficult.</p>
<p><code>Persistent</code> and <code>Local</code> no longer share the same type hierarchy and the way you instantiate and assign a <code>Persistent</code> has become quite awkward. You now have to go through enough gymnastics to create a <code>Persistent</code> that it makes you ask the question: <em>&quot;Do I really need this to be a <code>Persistent</code>?&quot;</em> Which I guess is a good thing for memory leaks. <a href="https://github.com/rvagg/nan">NAN</a> to the rescue though! We&#39;ve somewhat papered over those difficulties with the capabilities introduced in NAN, it&#39;s still not as easy as it once was but it&#39;s not a total headache.</p>
<p>So, you understand <code>v8::Persistent</code> now? Great, so back to LevelDOWN.</p>
<h3><code>Persistent</code> in LevelDOWN; some removed, some added!</h3>
<p><strong>Some removed</strong></p>
<p>Recently, <a href="https://github.com/mcollina">Matteo</a> noticed that when you&#39;re performing a <code>Batch()</code> operation in LevelDB, there is an explicit copy of the data that you&#39;re feeding in to that batch. When you construct a Batch operation in LevelDB you start off with a short string representing the batch and then build on that string as you build your batch with both <code>Put()</code> and <code>Del()</code> operations. You end up with a long string containing all of your write data; keys and values. Then when you call <code>Write()</code> on the Batch, that string gets fed directly into the main LevelDB store as a single write&mdash;which is where the atomicity of Batch comes from.</p>
<p>Both the chained-form and array-form <code>batch()</code> operations work this way internally in LevelDOWN.</p>
<p>However, with almost all operations in LevelDOWN, we perform the actual writes and reads against LevelDB in libuv worker threads. So we have to create the &quot;descriptor&quot; for work in the main V8 Node thread and then hand that off to libuv to perform the work in a separate thread. Once the work is completed we get the results back in the main V8 Node thread from where we can trigger a callback. This is where <code>Persistent</code> references come in.</p>
<p>Before we hand off the work to libuv, we need to make <code>Persistent</code> references to any V8 object that we want to survive across the asynchronous operation. Obviously the main candidate for this is <code>callback</code> functions. Consider this code:</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo = %s&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>

<p>What we&#39;ve actually done is create an anonymous closure for our callback. It has nothing referencing it, so as far as V8 is concerned it&#39;s a candidate for garbage collection once the current thread of execution is completed. In Node however, we&#39;re doing asynchronous work with it and need it to survive until we actually call it. This is where <code>Persistent</code> references come in. We receive the <code>callback</code> function as a <code>Local</code> in our C++ but then assign it to a <code>Persistent</code> so GC doesn&#39;t touch it. Once we&#39;re done our async work we can call the function and destroy the <code>Persistent</code>, effectively turning it back in to a <code>Local</code> and freeing it up for GC.</p>
<p>Without the <code>Persistent</code> then the behaviour is indeterminate. It depends on the version of V8, the GC settings, the workload currently in the program and the amount of time the async work takes to complete. If the GC is aggressive enough and has a chance to run before our async work is complete, the <code>callback</code> will disappear and we&#39;ll end up trying to call a function that no longer exists. This can obviously lead to runtime errors and will most likely crash our program.</p>
<p>In LevelDOWN, if you&#39;re passing in <code>String</code> objects for keys and values then to pull out the data and turn it in to a form that LevelDB can use we have to do an explicit <em>copy</em>. Once we&#39;ve copied the data from the <code>String</code> then we don&#39;t need to care about the original object and GC can get its hands on it as soon as it wants. So we can leave <code>String</code> objects as <code>Local</code> references while we are building the descriptor for our async work.</p>
<p><code>Buffer</code> objects are a different matter all together. Because we have access to the raw character array of a <code>Buffer</code>, we can feed that data straight in to LevelDB and this will save us one <em>copy</em> operation (which can be a significant performance boost if the data is significantly large or you&#39;re doing lots of operations&mdash;so prefer <code>Buffer</code>s where convenient if you need higher perf). When building the descriptor for the async work, we are just passing a character array to the LevelDB data structures that we&#39;re setting up. Because the data is shared with the original <code>Buffer</code> we have to make sure that GC doesn&#39;t clean up that <code>Buffer</code> before we have a chance to use the data. So we make a <code>Persistent</code> reference for it which we clean up after the async work is complete. So you can do this without worrying about GC:</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">).</span><span class="nx">randomBytes</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
  <span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo is now some random data!&#39;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>

<p>This has been the case in LevelDOWN for all operations since pretty much the beginning. But back to Matteo&#39;s observation. If LevelDB&#39;s data structures perform an explicit copy on the data we feed it then perhaps we don&#39;t need to keep the original data safe from GC? For a <code>batch()</code> call it turns out that we don&#39;t! When we&#39;re constructing the Batch descriptor, as we feed in data to it, both <code>Put()</code> and <code>Del()</code>, it&#39;s taking a copy of our data to create its internal representation. So even when we&#39;re using <code>Buffer</code> objects on the JavaScript side, we&#39;re done with them before the call down in to LevelDOWN is completed so there&#39;s no reason to save a <code>Persistent</code> reference! For other operations we&#39;re still doing some copying during the asynchronous cycle but the removal of the overhead of creating and deleting <code>Persistent</code> references for <code>batch()</code> calls is fantastic news for those doing bulk data loading (like Max Ogden&#39;s <a href="https://github.com/maxogden/dat">dat</a> project which needs to bulk load a <em>lot</em> of data).</p>
<p><strong>Some added</strong></p>
<p>Another gem from Matteo was reports of crashes during certain <code>batch()</code> operations. Difficult to reproduce and only under very particular circumstances, it seems to be mostly reproducible by the kinds of workloads generated by LevelGraph. Thanks to some simple C++ debugging we traced it to a dropped reference, obviously by GC. The code in question boiled down to something like this:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">doStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>In this code, the <code>batch</code> object is actually a LevelDOWN <code>Batch</code> object created in C++-land. During the <code>write()</code> operation, which is asynchronous, we end up with no hard references to <code>batch</code> in our code because the JS thread has yieled and moved on and the <code>batch</code> is contained within the scope of the <code>doStuff()</code> function. Because most of the asynchronous operations we perform are relatively quick, this normally doesn&#39;t matter. But for writes to LevelDB, if you have enough data in your write and you have enough data already in your data store, you can trigger a compaction upstream which can delay the write which can give V8&#39;s GC time to clean up references that might be important and for which you have no <code>Persistent</code> handles.</p>
<p>In this case, we weren&#39;t actually creating internal <code>Persistent</code> references for some of our objects. <code>Batch</code> in this case but also <code>Iterator</code>. Normally this isn&#39;t a problem because to use these objects you <em>generally</em> keep references to them yourself in your own code.</p>
<p>We managed to debug Matteo&#39;s crash by adjusting his test code to look something like this and watching it succeed without a crash:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">doStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">batch</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>By reusing <code>batch</code> inside our <code>callback</code> function, we&#39;re creating some work that V8 can&#39;t optimise away and therefore has to assume isn&#39;t a noop. Because the <code>batch</code> variable is also now referenced by the <code>callback</code> function and we already have an internal <code>Persistent</code> for it, GC has to pass over <code>batch</code> until the <code>Persistent</code> is destroyed for the <code>callback</code>.</p>
<p>So the solution is simply to create a <code>Persistent</code> for the internal objects that need to survive across asynchronous operations and make no assumptions about how they&#39;ll be used in JavaScript-land. In our case we&#39;ve gone for assigning a <code>Persistent</code> just prior to every asynchronous operation and destroying it after. The alternative would be to have a <code>Persistent</code> assigned upon the creation of objects we care about but sometimes we want GC to do its work:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">dontDoStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="c1">// nothing else, wut?</span>
<span class="p">}</span>
</pre></div>

<p>I don&#39;t know why you would write that code but perhaps you have a use-case where you want the ability to start constructing a batch but then decide not to follow through with it. GC should be able to take care of your mess like it does with all of the other messes you create in your daily adventures with JavaScript.</p>
<p>So we are only assigning a <code>Persistent</code> when you do a <code>write()</code> with a chained-batch operation in LevelDOWN since it&#39;s the only asynchronous operation. So in <code>dontDoStuff()</code> GC will come along and rid us of <code>batch</code>, <code>&#39;foo&#39;</code> and <code>&#39;bar&#39;</code> when it has the next opportunity and our C++ code will have the appropriate destructors called that will clean up any other objects we have created along the way, like the internal LevelDB <code>Batch</code> with its copy of our data.</p>
<h3>Leaks!</h3>
<p>We&#39;ve been having some trouble with leaks in LevelUP/LevelDOWN lately <em>(<a href="https://github.com/rvagg/node-levelup/issues/171">LevelDOWN/#171</a>, <a href="https://github.com/mcollina/levelgraph/issues/40">LevelGraph/#40</a>)</em>. And it turns out that these leaks aren&#39;t related to <code>Persistent</code> references, which shouldn&#39;t be a surprise since it&#39;s so easy to leak with non-GC code, particularly if you spend most of your day programming in a language with GC.</p>
<p>With the help of <a href="http://valgrind.org/">Valgrind</a> we tracked the leak down to the omission of a <code>delete</code> in the destructor of the asynchronous work descriptor for array-batch operations. The internal LevelDB representation of a Batch wasn&#39;t being cleaned up unless you were using the chained-form of LevelDOWN&#39;s <code>batch()</code>. This one has been dogging us for a few releases now and it&#39;s been a headache particularly for people doing bulk-loading of data so I hope we can finally put it behind us!</p>
<h3>Snappy 1.1.1</h3>
<p>Google released a new version of Snappy, version 1.1.1. I don&#39;t really understand how Google uses <a href="http://semver.org/">semver</a>; we get very simple LevelDB releases with the minor version bumped and then we get versions of Snappy released with non-trivial changes with only the patch version bumped. I suspect that Google doesn&#39;t know how it uses semver either and there&#39;s no internal policy on it.</p>
<p>Anyway, Snappy 1.1.1 has some fixes, some minor speed and compression improvements but most importantly it breaks compilation on Windows. So we had to figure out how to fix that for this release. Ugh. I also took the opportunity to clean up some of the compilation options for Snappy and we may see some improvements in the way it works now... perhaps.</p>
<h3>Some embarrassing bugs</h3>
<p><a href="https://github.com/Kyotoweb">Amine Mouafik</a> is new to the LevelDOWN repository but has picked up some rather embarrassing bugs/omissions that are probably my fault. It&#39;s great to have more eyes on the C++ code, there&#39;s not enough JavaScript programmers with the confidence to dig in to messy C++-land.</p>
<p>Firstly, on our standard LevelDOWN releases, it turns out that we haven&#39;t actually been enabling the internal <strong>bloom filter</strong>. The bloom filter was introduced in LevelDB to speed up read operations to avoid having to scan through whole blocks to find the data a read is looking for. So that&#39;s now enabled for 0.10.</p>
<p>Then he discovered that we had been <strong>turning off compression</strong> by default! I believe this happened with the the switch to NAN. The signature for reading boolean options from V8 objects was changed from internal <code>LD_BOOLEAN_OPTION_VALUE</code> &amp; <code>LD_BOOLEAN_OPTION_VALUE_DEFTRUE</code> macros for defaulting to true and false respectively when the options aren&#39;t supplied, to the NAN version which is a unified <code>NanBooleanOptionValue</code> which takes an optional <code>defaultValue</code> argument that can be used to make the default <code>true</code>. This happened at roughly Node version 0.11.4.</p>
<p>Well, this code:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">compression</span> <span class="o">=</span>
    <span class="n">NanBooleanOptionValue</span><span class="p">(</span><span class="n">optionsObj</span><span class="p">,</span> <span class="n">NanSymbol</span><span class="p">(</span><span class="s">&quot;compression&quot;</span><span class="p">));</span>
</pre></div>

<p>is now this:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">compression</span> <span class="o">=</span>
    <span class="n">NanBooleanOptionValue</span><span class="p">(</span><span class="n">optionsObj</span><span class="p">,</span> <span class="n">NanSymbol</span><span class="p">(</span><span class="s">&quot;compression&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
</pre></div>

<p>so if you don&#39;t supply a <code>&quot;compression&quot;</code> boolean option in your db setup operation then it&#39;ll now actually be turned on!</p>
<h3>Domains</h3>
<p>We&#39;ve finally caught up with properly supporting Node&#39;s <a href="http://nodejs.org/docs/latest/api/domain.html">domains</a> by switching all C++ <code>callback</code> calls from standard V8 <code>callback-&gt;Call(...)</code> to Node&#39;s own <code>node::MakeCallback(callback, ...)</code> which does the same thing but also does lots of additional things, including accounting for domains. This change was also included in NAN version 0.5.0.</p>
<h3>Summary</h3>
<p><strong>Go and upgrade!</strong></p>
<p>leveldown@0.10.0 is packaged with the new levelup@0.18.0 and level@0.18.0 which have their minor versions bumped purely for this LevelDOWN release.</p>
<p>Also released are the packages:</p>
<ul>
<li>leveldown-hyper@0.10.0</li>
<li>leveldown-basho@0.10.0</li>
<li>rocksdb@0.10.0 (based on the same LevelDOWN code) (Linux only)</li>
<li>level-hyper@0.18.0 (levelup on leveldown-hyper)</li>
<li>level-basho@0.18.0 (levelup on leveldown-basho)</li>
<li>level-rocks@0.18.0 (levelup on rocksdb) (Linux only)</li>
</ul>
<p>I&#39;ll write more about these packages in the future since they&#39;ve gone largely under the radar for most people. If you&#39;re interested in catching up then please join <strong>##leveldb</strong> on Freenode where there&#39;s a bunch of Node database people and also a few non-Node LevelDB people like <a href="https://twitter.com/rescrv">Robert Escriva</a>, author of HyperLevelDB and all-round LevelDB expert.</p>
<h3><em>A final note on Node 0.11.9</em></h3>
<p>There will be a LevelDOWN@0.10.1 very soon that will increment the NAN dependency to 0.6.0 when it&#39;s released. This new version of NAN will specifically deal with Node 0.11.9 compatibility where there are more breaking V8 changes that will cause compile errors for any addon not taking them in to account. So if you&#39;re living on the edge in Node then we should have a release soon enough for you!</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="all-the-levels"><a href="/2013/10/all-the-levels.html">All the levels!</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 9, 2013</p>
        <p class="link"><a href="/2013/10/all-the-levels.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/all-the-levels.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>When we completely separated <a href="https://github.com/rvagg/node-levelup">LevelUP</a> and <a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a> so that installing LevelUP didn&#39;t automatically get you LevelDOWN, we set up a new package called <strong><a href="https://github.com/Level/level">Level</a></strong> that has them both as a dependency so you just need to do <code>var level = require(&#39;level&#39;)</code> and everything is done for you.</p>
<p>But, we now have more than just the vanilla (Google) LevelDB in LevelDOWN. We also have a HyperLevelDB version and a Basho fork. These are maintained on branches in the LevelDOWN repo and are usually released now every time a new LevelDOWN is released. They are called <strong>leveldown-hyper</strong> and <strong>leveldown-basho</strong> in npm but you need to plug them in to LevelUP yourself to make them work. We also have <a href="https://github.com/rvagg/lmdb">Node LMDB</a> that&#39;s LevelDOWN compatible and a few others.</p>
<p>So, as of today, we&#39;ve released a new, small library called <strong><a href="https://github.com/level/level-packager">level-packager</a></strong> that does this bundling process so that you can feed it a LevelDOWN instance and it&#39;ll return a Level-type object that can be exported from a package like <strong>Level</strong>. This is meant to be used internally and it&#39;s now being used to support these new packages that are available in npm:</p>
<ul>
<li><strong><a href="https://github.com/Level/level-hyper">level-hyper</a></strong> bundles the HyperLevelDB version of LevelDOWN with LevelUP</li>
<li><strong><a href="https://github.com/Level/level-basho">level-basho</a></strong> bundles the Bash fork of LevelDB in LevelDOWN with LevelUP</li>
<li><strong><a href="https://github.com/Level/level-lmdb">level-lmdb</a></strong> bundles Node LMDB with LevelUP</li>
</ul>
<p>The version numbers of these packages will track the version of LevelUP.</p>
<p>So you can now simply do:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">level</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level-hyper&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">level</span><span class="p">(</span><span class="s1">&#39;/path/to/db&#39;</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;woohoo!&#39;</span><span class="p">)</span>
</pre></div>

<p>If you&#39;re already using <strong>Level</strong> then you can very easily switch it out with one of these alternatives to try them out.</p>
<p>Both HyperLevelDB and the Basho LevelDB fork are binary-compatible with Google&#39;s LevelDB, with one small caveat: with the latest release, LevelDB has switched to making <em>.ldb</em> files instead of <em>.sst</em> files inside a data store directory because of something about Windows backups (blah blah). Neither of the alternative forks know anything about these new files yet so you may run in to trouble if you have <em>.ldb</em> files in your store (although I&#39;m pretty sure you can simply rename these to <em>.sst</em> and it&#39;ll be fine with any version).</p>
<p>Also, LMDB is completely different to LevelDB so you won&#39;t be able to open an existing data store. But you should be able to do something like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">)(</span><span class="s1">&#39;/path/to/level.db&#39;</span><span class="p">).</span><span class="nx">createReadStream</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level-lmdb&#39;</span><span class="p">)(</span><span class="s1">&#39;/path/to/lmdb.db&#39;</span><span class="p">).</span><span class="nx">createWriteStream</span><span class="p">())</span>
</pre></div>

<p>Whoa...</p>
<h3>A note about HyperLevelDB</h3>
<p>Lastly, I&#39;d like to encourage you to try the HyperLevelDB version if you are pushing hard on LevelDB&#39;s performance. The HyperDex fork is tuned for multi-threaded access for reads and writes and is therefore particularly suited to how we use it in Node. The Basho version doesn&#39;t show much performance difference mainly because they are optimising for Riak running 16 separate instances on the same server so multi-threaded access isn&#39;t as interesting for them. You should find significant performance gains if you&#39;re doing very heavy writes in particular with HyperLevelDB. Also, if you&#39;re interested in support for HyperLevelDB then pop in to ##leveldb on Freenode and bother <em><a href="https://twitter.com/rescrv">rescrv</a></em> (Robert Escriva), author of HyperLevelDB and our resident LevelDB expert.</p>
<p>It&#39;s also worth nothing that HyperDex are interested in offering commercial support for people using LevelDB, not just HyperLevelDB but also Google&#39;s LevelDB. This means that anyone using either of these packages in Node should be able to get solid support if they are doing any heavy work in a commercial environment and need the surety of experts behind them to help pick up the pieces. I imagine this would cover things like LevelDB corruption and any LevelDB bugs you may run in to (we&#39;re currently looking at a subtle <a href="https://github.com/rvagg/node-levelup/issues/171">batch-related LevelDB bug</a> that&#39;s come along with the 1.14.0 release, they do exist!). Talk to Robert if you want more information about commercial support.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="should-i-use-a-single-leveldb-or-many-to-hold-my-data"><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html">Should I use a single LevelDB or many to hold my data?</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 3, 2013</p>
        <p class="link"><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>This is a long overdue post, so long in fact that I can&#39;t remember who I promised to do this for! Regardless, I keep on having discussions around this topic so I thought it worthwhile putting down some notes on what I believe to be the factors you should consider when making this decision.</p>
<h3>What&#39;s the question?</h3>
<p>It goes like this: You have an application that uses LevelDB, in particular I&#39;m talking about Node.js applications here but the same would apply if you&#39;re using LevelUP in the browser and also most of the other back-ends for LevelUP. And you invariably end up with different kinds of data, sometimes the kinds of data you&#39;re storing is so different that it feels strange putting them into the same storage blob. Often though, you just have sets of not-very-related data that you need to store and you end up having to make a decision: <strong>do I put everything into a single LevelDB store or do I put things into their own, separate, LevelDB store?</strong></p>
<h3>This stuff doesn&#39;t <em>belong</em> together!</h3>
<p>Coming from an relational database background, it took me a little while to displace the concept of discrete <em>tables</em> with the notion of <em>namespacing</em> within the same store. I can understand the temptation to want to keep things separate, not wanting to end up with a huge blob of data that just <em>shouldn&#39;t be together</em>. But this isn&#39;t the relational database world and you need to move on!</p>
<p>We have a set of LevelUP addons, such as <a href="https://github.com/dominictarr/level-sublevel">sublevel</a>, that exist mainly to provide you with the comfort of being able to separate your data by whatever criteria makes sense. <a href="https://github.com/deanlandolt/bytewise">bytewise</a> is another tool that can serve a similar purpose and some people even use sublevel and bytewise together to achieve more complex organisation.</p>
<p><strong>We have the tools at our disposal in Node.js to turn a one-dimensional storage array into a very complex, multidimensional storage <em>system</em> where unrelated, and semi-related data can coexist.</strong> So, if the only reason you want to store things in separate stores is because it just <em>feels</em> right to do so, you should probably be looking at what&#39;s making you think that way. You may need to update your assumptions.</p>
<h3>Technical considerations</h3>
<p>That aside, there are some technical considerations for making this decision:</p>
<h4>Size and performance</h4>
<p>To be clear, <strong>LevelDB is fast</strong> and it can also store <strong>lots of data</strong>, it&#39;ll handle Gigabytes of data without too much sweat. However, there <em>are</em> some performance concerns when you start getting in to the Gigabyte range, mainly when you&#39;re trying to push data in at a high rate. Most use-cases don&#39;t do this so be honest about your performance needs. For most people LevelDB is simply fast.</p>
<p>However, if you do have a high-throughput scenario involving a large amount of data that you need to store then you may want to consider having a separate store to deal with the large data and another one to deal with the rest of your data so the performance isn&#39;t impacted across the board.</p>
<p>But again, be honest about what your workload is, you&#39;re probably not pushing <a href="http://voxer.com">Voxer</a> amounts of data so don&#39;t prematurely optimise around the workload you&#39;d like to think you have or are going to have one day in the distant future.</p>
<h3>Cache</h3>
<p>Caching is transparent by default with LevelDB so it&#39;s easy to forget about it when making these kinds of decisions but it&#39;s actually quite important for this particular question.</p>
<p>By default, you have an 8M LRU cache with LevelDB and <em>all</em> reads use that cache, for look-ups and also for updating with newly read values. So, you can have a lot of cache-thrash unless you&#39;re reading the same values again and again. </p>
<p>But, there is a <code>fillCache</code> (boolean) option for read operations (both <code>get()</code> and <code>createReadStream()</code> and its variations). So you can set this to <code>false</code> where you know you won&#39;t be needing fast access to those entries again and you don&#39;t want to push out other entries from the LRU.</p>
<p>So caching strategies can be separate for different types of data and are not a strong reason to keep things in a separate data store.</p>
<p>I always recommend that you should tinker with the <code>cacheSize</code> option when you&#39;re using LevelDB, it can be as large as you want to fit in the available memory of your machine. As a rule of thumb, somewhere between 2/3 and 3/4 of the available memory should be a maximum if you can afford it.</p>
<p>Consider though what happens if you are using separate LevelDB stores, you now have to deal with juggling <code>cacheSize</code> between the stores. Often, you&#39;re probably going to be best served by having a single, large cache that can operate across all your data types and let the normal behaviour of your application determine what gets cached with occasional reliance on <code>&#39;fillCache&#39;: false</code> to fine-tune. </p>
<h3>Consistency</h3>
<p>As I discussed in my <a href="http://r.va.gg/presentations/lxjs2013/">LXJS</a> talk, the <em>atomic batch</em> is an important primitive for building solid database functionality with inherent <em>consistency</em>. When you&#39;re using <strong>sublevel</strong>, even though you have what operate like separate LevelUP instances for each sublevel, you still get to perform atomic batch operations between sublevels. Consider indexing where you may have a primary sublevel for the entries you&#39;re writing and a secondary sublevel for the indexing data used to reference the primary data for lookups. If you&#39;re running these as separate stores then you lose the benefits of the atomic batch, you just can&#39;t perform multiple operations with guaranteed consistency.</p>
<p>Try and keep the atomic batch in mind when building your application, instead of accepting the possibility of inconsistent state, use the batch to keep consistency.</p>
<h3>Back-end flexibility</h3>
<p>OK, this one is a bit left-field, but remember that LevelUP is back-end-agnostic. It&#39;s inspired by LevelDB but it doesn&#39;t have to be Google&#39;s LevelDB that&#39;s storing data for you. It could be Basho&#39;s fork or HyperLevelDB. It could even be LMDB or something a little crazy like MemDOWN or mysqlDOWN! </p>
<p>If you&#39;re at all concerned about performance, and most people claim to be even though they&#39;re not building performance-critical applications, then you should be benchmarking your particular workload against your storage system. Each of the back-ends for LevelUP have different performance characteristics and different trade-offs that you need to understand and test against your needs. You may find that one back-end works for one kind of data in your application and another back-end works for another.</p>
<h3>Summary</h3>
<p>The TL;DR is: in most cases, a single LevelDB store is generally preferable unless you have a <em>real</em> reason for having separate ones.</p>
<p>Have I missed any considerations that you&#39;ve come across when making this choice? Let me know in the comments.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="primitives-for-js-databases-an-lxjs-adventure"><a href="/2013/10/primitives-for-js-databases-an-lxjs-adventure.html">Primitives for JS Databases (an LXJS adventure)</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 3, 2013</p>
        <p class="link"><a href="/2013/10/primitives-for-js-databases-an-lxjs-adventure.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/primitives-for-js-databases-an-lxjs-adventure.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>I gave a talk yesterday at <strong><a href="http://2013.lxjs.org">LXJS</a></strong> yesterday in the <em>&quot;Infrastructure.js&quot;</em> block and tried to talk about JavaScript Database Primitives; i.e. the basic building blocks we have landed on for building more complex database solutions in JavaScript.</p>
<p>The talk certainly wasn&#39;t as good or clear as I wanted it to be, it worked much better in my head! A huge venue with over 300 talented JavaScripters, an absolutely massive screen, bright lights and loud amplification got the better of me and I wasn&#39;t able to pull the material together how I wanted to. The introvert within me is telling me to become a recluse for a little while just to recover! My <em>hope</em> is that at least one or two people are inspired to give <em>database hacking</em> a go because it&#39;s really not that difficult once you get your head around the primitives.</p>
<p><strong><em>Edit:</em></strong> <em>I wasn&#39;t trying to elicit sympathy here, I genuinely think that I wasn&#39;t clear on what I was trying to communicate. It went so well in my head, as it usually does, but I fell far short of what I wanted to express. I&#39;ll attempt to rectify some of that with a writeup (see next para).</em></p>
<p>Thankfully though, a portion of the material will be able to serve as the basis for the, long overdue, third part in my <a href="http://dailyjs.com/2013/04/19/leveldb-and-node-1/">three</a> <a href="http://dailyjs.com/2013/05/03/leveldb-and-node-2/">part</a> <a href="http://dailyjs.com">DailyJS</a> series on LevelDB &amp; Node.</p>
<p>In summary, inspired by LevelDB, we&#39;ve ended up with a core set of primitives in <a href="https://github.com/rvagg/node-levelup">LevelUP</a> that can be used to build feature-rich and advanced database functionality. <strong>Atomic batch</strong> and <strong>ReadStream</strong> are the two non-trivial primitives, open, close, get, put, del are all pretty easy to understand as primitives, although <em>del</em> is perhaps redundant but we&#39;re opting for explicitness.</p>
<p>My <a href="http://r.va.gg/presentations/lxjs2013">slides are online</a> but hopefully I&#39;ll be able to get my DailyJS article sorted out soon and I&#39;ll be able to explain what I was trying to get at.</p>
<p>ReadStream as a primitive query mechanism is not too hard to understand once you get your head around key sorting and the implications for key structure. Batch is a little more subtle and relates to consistency and our ability to augment basic operations to create more complex functionality while keeping the data store in a consistent state.</p>
<p>I additionally raised &quot;Buckets&quot;, or &quot;Namespaces&quot; as a primitive concept and discussed how <a href="https://github.com/dominictarr/level-sublevel">sublevel</a> has effectively become the standard for turning a one-dimensional data store into a multi-dimensional store able to encapsulate contain sophisticated functionality behind what is essentially just a key/value store.</p>
<h3>Thanks to the LXJS team</h3>
<p>It would be neglectful of me to not say how absolutely grateful I am to the LXJS team for putting so much effort into taking care of speakers; fantastic job.</p>
<p>LXJS is an amazing event, put on by a dedicated and very talented team of people committed to the JavaScript community and the JavaScript community in Portugal in particular. This conference sets a very high bar for community-driven conferences with the way it has managed to get so many locals (and internationals!) involved in running an event in their own time.</p>
<p><strong>David Dias, Ana Hevesi, Pedro Teixeira, Luís Reis, Nuno Job, Tiago Rodrigues, Leo Xavier, Alexander Kustov, André Rodrigues and Bruno Coelho</strong> have managed to put on an amazing event and are some of the nicest and talented people I&#39;ve met. Thank you to you all and everyone else who put on LXJS 2013, your hard work is appreciated and should be an inspiration to everyone involved in our local JavaScript communities, running events or considering running events like this.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="nodeconf.eu"><a href="/2013/09/nodeconf.eu.html">NodeConf.eu</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on September 27, 2013</p>
        <p class="link"><a href="/2013/09/nodeconf.eu.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/09/nodeconf.eu.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>Wow, <strong><a href="http://nodeconf.eu/">NodeConf.eu</a></strong> was certainly a once-in-a-lifetime event ... although there&#39;s talk of a repeat performance next year (don&#39;t miss the chance when it comes around!).</p>
<div style="text-align: center;">
<img src="http://r.va.gg/images/2013/09/nodeconfeu_raiseflag.jpg" alt="Raise that flag">
<p style="text-align: center;">Dominic Tarr, @substack and Julian Gruber raising the NodeConf.eu flag</p>
</div>


<p>NodeConf.eu was held in Waterford, Ireland, on an <strong>Island</strong>, in a <strong>Castle</strong> and was organised by the Node lovin&#39; company, <a href="http://nearform.com/">nearForm</a>, in particular <a href="http://cianomaidin.com/">Cian O&#39;Maidin</a> and his amazing assistant Catherine Bradley. Of course <a href="http://futurealoof.com/">Mikeal Rogers</a> had a significant role in organising the event too.</p>
<div style="text-align: center;">
<img src="http://r.va.gg/images/2013/09/nodeconfeu_castle.jpg" alt="Waterford Castle">
<p style="text-align: center;"><a href="http://waterfordcastle.com/">Waterford Castle</a></p>
</div>

<div style="text-align: center;">
<img src="http://r.va.gg/images/2013/09/nodeconfeu_pig.jpg" alt="Pig">
<p style="text-align: center;">The welcome banquet ... yep</p>
</div>

<p>Instead of describing the talks, I&#39;ll defer to the <a href="http://clock.co.uk/tech-blogs/nodeconfeu-2013-part-one">excellent</a> <a href="http://clock.co.uk/tech-blogs/nodeconfeu-2013-part-two">four</a> <a href="http://clock.co.uk/tech-blogs/nodeconfeu-2013-part-three">part</a> <a href="http://clock.co.uk/tech-blogs/nodeconfeu-reflection">series</a> by Paul, Adam, Luke and Ben of <a href="http://clock.co.uk/">Clock</a> where you&#39;ll find a great summary of the talks and events of the conference.</p>
<p>For my part, I was deeply honoured to be involved in the <em>&quot;Node Databases&quot;</em> track of the conference. We started off the NodeConf.eu talks with a 3-part show. My talk was titled &quot;A Real Database Rethink&quot; and was followed by <a href="https://twitter.com/dominictarr">Dominic Tarr</a> who talked more about the Level* ecosystem and the various pieces of the Node Databases puzzle that&#39;s being built. <a href="http://juliangruber.com/">Julian Gruber</a> then closed us off with some amazing live-coding of some browser/server streaming LevelUP/multilevel <a href="https://github.com/juliangruber/nodeconfeu-13">wizardry</a>.</p>
<h3>A Real Database Rethink</h3>
<p>The slides of my talk are <a href="http://r.va.gg/presentations/nodeconfeu.2013/">online</a>. I attempted to break down the definition of the term <em>&quot;database&quot;</em> by looking at where the concept comes from historically. It&#39;s actually a difficult thing to define and I don&#39;t believe there is any one agreed upon meaning. What I came up with is:</p>
<blockquote>
<p>A tool for interacting with structured data, externalised from the core of our application</p>
<ul>
<li>Persistence</li>
<li>Performance</li>
<li>Simplify access to complex data</li>
</ul>
<p>And sometimes...</p>
<ul>
<li>Shared access</li>
<li>Scalability</li>
</ul>
</blockquote>
<p>But even that&#39;s pretty rough.</p>
<p>Taking that definition, we can apply Node philosophy of small-core and vibrant user-land, along with the culture of extreme modularity afforded us by npm, and build a new kind of database; or at least apply new thinking to the &quot;database&quot;.</p>
<p>The bulk of my talk was taken up with talking about LevelUP and the basics of the Level<em> ecosystem. There&#39;s a table on slide #7 that I&#39;m going to try and refine over time to help describe what the Level</em> / NodeBase world is all about.</p>
<h3>Level Me Up Scotty!</h3>
<p>One of the three workshops available at NodeConf.eu was all about Node Databases. I took the same approach as at <a href="http://campjs.com/">CampJS</a> recently where I built <a href="http://r.va.gg/2013/08/learn-you-the-node.js.html">Learn You The Node.js For Much Win!</a>, a tool that owes a debt to <a href="https://github.com/substack/stream-adventure">stream-adventure</a>, a self-guided workshop-in-your-terminal application by <a href="https://twitter.com/substack">@substack</a> and <a href="https://twitter.com/maxogden">Max Ogden</a> written for NodeConf (US).</p>
<p>This time around, I received some great help from both @substack and Julian Gruber who helped write some exercises, I also received help from <a href="http://twitter.com/eugeneware">Eugene Ware</a> who wasn&#39;t even at the conference but was assisting with development from Australia. <a href="http://twitter.com/raynos2">Raynos</a> was also a great help in getting the application working well.</p>
<p>We ended up with <strong><em>Level Me Up Scotty!</em></strong>, or just <strong>levelmeup</strong>.</p>
<div style="text-align: center;">
<img src="https://raw.github.com/rvagg/levelmeup/master/levelmeup.png" alt="levelmeup">
</div>

<p>Dominic Tarr, <a href="https://twitter.com/thlorenz">Thorsten Lorenz</a>, <a href="https://twitter.com/hij1nx">Paolo Fragomeni</a>, <a href="http://www.matteocollina.com/">Matteo Collina</a>, <a href="https://twitter.com/ralphtheninja">Magnus Skog</a>, Max Ogden and other experienced <em>Levelers</em> helped on and off while the workshops were happening; so we had plenty of expertise at hand whenever there were questions.</p>
<p>Workshops were unstructured and the organisers of each workshop all ended up agreeing that we should just let people come and go as they pleased. This suited us as the workshop was open-ended and designed not to be finished by most people within the originally planned hour <em>(I think that was the original plan)</em>.</p>
<p><strong><a href="https://github.com/rvagg/levelmeup">levelmeup</a></strong> is installed from npm (<code>npm install levelmeup -g</code>) and is fully self-guided. You run the <code>levelmeup</code> application and it steps you through some exercises designed to:</p>
<ul>
<li>introduce you to the format of the workshops with a simple &quot;Hello World&quot; style exercise</li>
<li>introduce you to LevelUP and its basic operations</li>
<li>help you understand ReadStream and the range-queries it makes possible</li>
<li>encourage creative thought regarding key structure</li>
<li>introduce <a href="https://github.com/dominictarr/level-sublevel">sublevel</a></li>
<li>introduce <a href="https://github.com/juliangruber/multilevel">multilevel</a></li>
</ul>
<p>There&#39;s more planned for the future of this workshop application too, Matteo even has an a <a href="https://github.com/rvagg/levelmeup/pull/19">work-in-progress exercise</a> that should be merged fairly soon.</p>
<p><strong><a href="http://nodeschool.io/">nodeschool.io</a></strong> was hatched from NodeConf.eu and pulls together the three workshop applications currently available in npm. I believe this was an initiative of <a href="https://twitter.com/brianloveswords">Brian J. Brennan</a> and other Mozillans on the <a href="http://openbadges.org/">Open Badges</a> project. <strong><a href="https://github.com/rvagg/workshopper">workshopper</a></strong> is the engine that runs both learnyounode and levelmeup and we&#39;re trying to make it even easier for others to author their own workshop applications. There is already a <a href="https://github.com/timoxley/functional-javascript-workshop/">Functional Javacript Workshop</a> by <a href="https://twitter.com/secoif">Tim Oxley</a> and there are more in development. Exciting times!</p>
<div style="text-align: center;">
<img src="http://r.va.gg/images/2013/09/nodeconfeu_levelmeup.jpg" alt="Level Me Up Workshoppers">
<p style="text-align: center;">Workshoppers stretching their brains with <strong>levelmeup</strong></p>
</div>

<p>My experience with <strong>stream-adventure</strong> and <strong>learnyounode</strong> suggested that this format should prove to be relatively successful but ultimately I think we had most of the attendees come through at some point and sit down to have a crack at the workshop. This is particularly impressive given that <a href="http://nexxylove.tumblr.com/">Emily Rose</a>, <a href="http://tmpvar.com/">Elijah Insua</a> and Matteo were running a NodeBots workshop which included Arduino and NodeCopter hacking (always popular!). And <a href="https://twitter.com/mrbruning">Max Bruning</a> and <a href="https://twitter.com/tjfontaine">TJ Fontaine</a> were running a Manta / MDB / DTrace / SmartOS-magic workshop and their material was some of my favourite from NodeConf (US) so I&#39;m sure people really enjoyed what they had to present.</p>
<p>Unfortunately I didn&#39;t get to attend these other workshops, I also missed out on some skeet!</p>
<div style="text-align: center;">
<img src="http://farm6.staticflickr.com/5338/9726258926_e3ea4a656f_z.jpg" alt="Skeet">
<p style="text-align: center;">Karolina <em>&quot;don&#39;t mess with me&quot;</em> Szczur, photo by <a href="http://www.flickr.com/photos/matthewbergman/sets/72157635446400980/">Matthew Bergman</a></p>
</div>

<p>But there was plenty of other <em>experience</em> to be had. It was also fantastic to meet so many people I only knew from IRC / Twitter / GitHub. For someone who lives in regional Australia and doesn&#39;t get a chance to socialise much with other nerds, this was a particularly special opportunity.</p>
<div style="text-align: center;">
<img src="http://farm8.staticflickr.com/7392/9783982165_43ca4edef2_z.jpg" alt="Shenanigans">
<p style="text-align: center;">Final night banquet shenanigans with <a href="https://twitter.com/Av1anFlu">Charlie McConnell</a> and @substack ... the napkin hat thing is a story in itself, blame <a href="https://twitter.com/jllord">Jessica Lord</a>, photo by <a href="http://www.flickr.com/photos/matthewbergman/sets/72157635446400980/">Matthew Bergman</a></p>
</div>

<h3>The Level* Gang</h3>
<p>As an aside, NodeConf.eu had the largest concentration of LevelUP contributors and active Level* developers of any event that I&#39;m aware of so far. So we took the opportunity to have our own little meeting. We even took minutes, <a href="https://github.com/karolinaszczur/leveldb.org/blob/master/meetup-nodeland">of sorts</a>.</p>
<p>There has been a long-standing plan to make a Level* / NodeBase website but being the disorganised rabble we are, it hasn&#39;t got off the ground. Karolina (and Jessica too I believe) are keen to help out on the design end but just need the content. So that&#39;s what we planned. There&#39;s a bunch of issues that form a TODO in the <a href="https://github.com/karolinaszczur/leveldb.org/issues">repo</a> for this project. Hopefully we can all get on top of it sooner rather than later. We&#39;re also open to assistance from anyone else that would like to contribute.</p>
<p>Besides getting stuff done, it was just a pleasure to hang out with these people and talk <em>shop</em>.</p>
<div style="text-align: center;">
<img src="http://r.va.gg/images/2013/09/nodeconfeu_levelgang.jpg" alt="A momentus event">
<p style="text-align: center;"><strong>The Level* Gang</strong>: Paolo, Dominic, @substack, Karolina, Magnus, Mikeal, Julian, Max, Matteo and <a href="https://twitter.com/paulfryzel">Paul Fryzel</a>. Raynos was around but missed this particular <em>event</em>, Thorsten was inside demoing his guitar-typing software.</p>
</div>


      </section>

    </section>

  
</div>

  <section class="pager">
    
 

      <div class="next">
        <a href="/page1.html">&laquo; Older posts</a>
      </div>

    
  </section>
  <div style="clear: both;"></div>

  <!--
  <script type="text/javascript">
    var disqus_shortname = 'rvagg'

    !(function () {
      var s = document.createElement('script')
      s.async = true
      s.type = 'text/javascript'
      s.src = 'http://' + disqus_shortname + '.disqus.com/count.js'
      !(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s)
    }())
  </script>
  -->



      <section class="footer">
        &copy; Rod Vagg 2013, powered by <a href="https://github.com/rvagg/blorg">Blorg</a>
        <br><a href="http://r.va.gg/atom.xml">Atom / RSS feed</a>
      </section>

    </section>

  </body>
</html>