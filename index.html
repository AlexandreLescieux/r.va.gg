<!DOCTYPE HTML>
<html lang="en-us">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>r.va.gg</title>
    <link rel="stylesheet" href="/style.css" type="text/css">
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://r.va.gg/atom.xml" />
    <script type="text/javascript" src="http://use.typekit.com/swo4snt.js"></script>
    <script type="text/javascript">try{Typekit.load()}catch(e){}</script>  
    <script type="text/javascript">
      var _gaq = _gaq || []
      _gaq.push(['_setAccount', 'UA-21373682-1'])
      _gaq.push(['_trackPageview'])
      setTimeout('_gaq.push(["_trackEvent", "15_seconds", "read"])', 15000)
      !(function () {
        var ga = document.createElement('script')
        ga.type = 'text/javascript'
        ga.async = true
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'
        var s = document.getElementsByTagName('script')[0]
        s.parentNode.insertBefore(ga, s)
      }())
    </script>
  </head>
  <body>

    <section class="content">
      <h1>
        <a href="/">r.va.gg</a>
      </h1>

      <section class="nav">
        <section class="me">
          <span>Find me</span>
          <ul>
            <li>on <a href="https://twitter.com/rvagg">Twitter / @rvagg</a></li>
            <li>on <a href="https://github.com/rvagg">GitHub / @rvagg</a></li>
          </ul>
        </section>
        <section class="recent">
          <span>Recent posts</span>
          <ul>
            
 
                <li><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html">Testing code against many Node versions with Docker</a></li>
              
 
 
                <li><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">LevelDOWN v0.10 / managing GC in native V8 programming</a></li>
              
 
 
                <li><a href="/2013/10/all-the-levels.html">All the levels!</a></li>
              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
          </ul>
        </section>
      </section>
      <div style="clear: both;"></div>

      

<div id="for">
  

    <section class="post-content">

      <h2 id="testing-code-against-many-node-versions-with-docker"><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html">Testing code against many Node versions with Docker</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on November 26, 2013</p>
        <p class="link"><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/11/testing-code-against-many-node-versions-with-docker.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>I haven&#39;t found reason to play with <a href="http://www.docker.io">Docker</a> until now, but I&#39;ve finally came up with an excellent use-case.</p>
<p><a href="https://github.com/rvagg/nan">NAN</a> is a project that helps build native Node.js add-ons while maintaining compatibility with Node and V8 from Node versions 0.8 onwards. V8 is currently undergoing major internal changes which is making add-on development very difficult; NAN&#39;s purpose is to abstract that pain. Instead of having to manage the difficulties of keeping your code compatible across Node/V8 versions, NAN does it for you. But this means that we have to be sure to keep NAN tested and compatible with all of the versions it claims to support.</p>
<p><a href="https://travis-ci.org/">Travis</a> can help a little with this. It&#39;s possible to use <a href="https://github.com/creationix/nvm">nvm</a> to test across different versions of Node, we&#39;ve tried this with NAN (see the <a href="https://github.com/rvagg/nan/blob/ba82a9c1fba01b3df553ac624aeaf15ca3688315/.travis.yml">.travis.yml</a>). Ideally you&#39;d have better choice of Node versions, but Travis have had some <a href="https://github.com/travis-ci/travis-ci/issues/1328">difficulty</a> keeping up. Also, npm bugs make it difficult, with a high failure rate from npm install problems, like <a href="https://travis-ci.org/rvagg/nan/jobs/14440485">this</a> and <a href="https://travis-ci.org/rvagg/nan/jobs/14474613">this</a>, so I don&#39;t even publish the badge on the NAN README.</p>
<p>The other problem with Travis is that it&#39;s a CI solution, not a proper testing solution. Even if it worked well, it&#39;s not really that helpful in the development process, you need rapid feedback that your code is working on your target platforms (this is one reason why I love back-end development more than front-end development!)</p>
<p>Enter Docker and <strong><a href="https://github.com/rvagg/dnt">DNT</a></strong></p>
<div style="margin: 0 auto;">
  <img src="http://www.docker.io/static/img/homepage-docker-logo.png" width="138" height="114">
  <img src="http://nodejs.org/images/logos/nodejs-dark.png" width="212" height="114">
  <img src="http://img.pandawhale.com/29490-Picard-applause-clapping-gif-s5nz.gif" width="151" height="114">
</div>

<h3>DNT: Docker Node Tester</h3>
<p>Docker is a tool that simplifies the use of Linux containers to create lightweight, isolated compute &quot;instances&quot;. Solaris and its variants have had this functionality for years in the form of &quot;zones&quot; but it&#39;s a fairly new concept for Linux and Docker makes the whole process a lot more friendly.</p>
<p><strong>DNT</strong> contains two tools that work with Docker and Node.js to set-up containers for testing and run your project&#39;s tests in those containers.</p>
<div style="margin: 0 auto;">
  <img src="http://r.va.gg/images/2013/11/nan-dnt.png">
</div>

<p><strong>DNT</strong> includes a <code>setup-dnt</code> script that sets up the most basic Docker images required to run Node.js applications, nothing extra. It first creates an image called &quot;dev_base&quot; that uses the default Docker &quot;ubuntu&quot; image and adds the build tools required to compile and install Node.js</p>
<p>Next it creates a &quot;node_dev&quot; image that contains a complete copy of the Node.js <a href="http://github.com/joyent/node">source repository</a>. Finally, it creates a series of images that are required; for each Node version, it creates an image with Node installed and ready to use.</p>
<p>Setting up a project is a matter of creating a <em>.dntrc</em> file in the root directory of the project. This configuration file involves setting a <code>NODE_VERSIONS</code> variable with a list of all of the versions of Node you want to test against, and this can include &quot;master&quot; to test the latest code from the Node repository. You also set a <code>TEST_CMD</code> variable with a series of commands required to set up, compile and execute your tests. The <code>setup-dnt</code> command can be run against a <em>.dntrc</em> file to make sure that the appropriate Docker images are ready. The <code>dnt</code> command can then be used to execute the tests against all of the Node versions you specified.</p>
<p>Since Docker containers are completely isolated, <strong>DNT</strong> can run tests in parallel as long as the machine has the resources. The default is to use the number of cores on the computer as the concurrency level but this can be configured if not appropriate.</p>
<p>Currently <strong>DNT</strong> is designed to parse TAP test output by reading the final line as either &quot;ok&quot; or &quot;not ok&quot; to report test status back on the command-line. It is configurable but you need to supply a command that will transform test output to either an &quot;ok&quot; or &quot;not ok&quot; (<code>sed</code> to the rescue?).</p>
<h3>How I&#39;m using it</h3>
<p>My primary use-case is for testing <strong>NAN</strong>. The test suite needs a lot of work so being able to test against all the different V8 and Node APIs while coding is super helpful; particularly when tests run so quickly! My NAN <em>.dntrc</em> file tests against master, all of the 0.11 releases since 0.11.4 (0.11.0 to 0.11.3 are explicitly not supported by NAN) and the last 5 releases of the 0.10 and 0.8 series. At the moment that&#39;s 17 versions of Node in all and on my computer the test suite takes approximately 20 seconds to complete across all of these releases.</p>
<p><strong>The NAN <a href="https://raw.github.com/rvagg/nan/master/.dntrc">.dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  master   \</span>
<span class="s2">  v0.11.9  \</span>
<span class="s2">  v0.11.8  \</span>
<span class="s2">  v0.11.7  \</span>
<span class="s2">  v0.11.6  \</span>
<span class="s2">  v0.11.5  \</span>
<span class="s2">  v0.11.4  \</span>
<span class="s2">  v0.10.22 \</span>
<span class="s2">  v0.10.21 \</span>
<span class="s2">  v0.10.20 \</span>
<span class="s2">  v0.10.19 \</span>
<span class="s2">  v0.10.18 \</span>
<span class="s2">  v0.8.26  \</span>
<span class="s2">  v0.8.25  \</span>
<span class="s2">  v0.8.24  \</span>
<span class="s2">  v0.8.23  \</span>
<span class="s2">  v0.8.22  \</span>
<span class="s2">&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;nan-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  cd /dnt/test/ &amp;&amp;                                               \</span>
<span class="s2">  npm install &amp;&amp;                                                 \</span>
<span class="s2">  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild &amp;&amp; \</span>
<span class="s2">  node_modules/.bin/tap js/*-test.js;                            \</span>
<span class="s2">&quot;</span>
</pre></div>

<p>Next I configured <strong><a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a></strong> for <strong>DNT</strong>. The needs are much simpler, the tests need to do a compile and run a lot of node-tap tests.</p>
<p><strong>The LevelDOWN <a href="https://raw.github.com/rvagg/node-leveldown/master/.dntrc">.dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  master   \</span>
<span class="s2">  v0.11.9  \</span>
<span class="s2">  v0.11.8  \</span>
<span class="s2">  v0.10.22 \</span>
<span class="s2">  v0.10.21 \</span>
<span class="s2">  v0.8.26  \</span>
<span class="s2">&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;leveldown-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  cd /dnt/ &amp;&amp;                                                    \</span>
<span class="s2">  npm install &amp;&amp;                                                 \</span>
<span class="s2">  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild &amp;&amp; \</span>
<span class="s2">  node_modules/.bin/tap test/*-test.js;                          \</span>
<span class="s2">&quot;</span>
</pre></div>

<p>Another native Node add-on that I&#39;ve set up with <strong>DNT</strong> is my <a href="https://github.com/rvagg/node-libssh">libssh bindings</a>. This one is a little more complicated because you need to have some non-standard libraries installed before compile. My <em>.dntrc</em> adds some extra <code>apt-get</code> sauce to fetch and install those packages. It means the tests take a little longer but it&#39;s not prohibitive. An alternative would be to configure the <em>node_dev</em> base-image to have these packages to all of my versioned images have them too.</p>
<p><strong>The node-libssh <a href="https://raw.github.com/rvagg/node-libssh/master/.dntrc">.dntrc</a></strong></p>
<div class="highlight"><pre><span class="nv">NODE_VERSIONS</span><span class="o">=</span><span class="s2">&quot;master v0.11.9 v0.10.22&quot;</span>
<span class="nv">OUTPUT_PREFIX</span><span class="o">=</span><span class="s2">&quot;libssh-&quot;</span>
<span class="nv">TEST_CMD</span><span class="o">=</span><span class="s2">&quot;\</span>
<span class="s2">  apt-get install -y libkrb5-dev libssl-dev &amp;&amp;                           \</span>
<span class="s2">  cd /dnt/ &amp;&amp;                                                            \</span>
<span class="s2">  npm install &amp;&amp;                                                         \</span>
<span class="s2">  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild --debug &amp;&amp; \</span>
<span class="s2">  node_modules/.bin/tap test/*-test.js --stderr;                         \</span>
<span class="s2">&quot;</span>
</pre></div>

<h3>What&#39;s next?</h3>
<p>I have no idea but I&#39;d love to have helpers flesh this out a little more. It&#39;s not hard to imagine this forming the basis of a local CI system as well as a general testing tool. The speed even makes it tempting to run the tests on every git commit, or perhaps on every save.</p>
<p>If you&#39;d like to contribute to development then please submit a pull request, I&#39;d be happy to discuss anything you might think would improve this project. I&#39;m keen to share ownership with anyone making significant contributions; as I do with most of my open source projects.</p>
<p>See the <strong><a href="https://github.com/rvagg/dnt">DNT</a></strong> GitHub repo for installation and detailed usage instructions.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="leveldown-v0.10-managing-gc-in-native-v8-programming"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">LevelDOWN v0.10 / managing GC in native V8 programming</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on November 18, 2013</p>
        <p class="link"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/11/leveldown-v0.10-managing-gc-in-native-v8-programming.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p><img src="https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png" alt="LevelDB"></p>
<p>Today we released version 0.10 of <a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a>. LevelDOWN is the package that directly binds LevelDB into Node-land. It&#39;s mainly C++ and is a fairly raw &amp; direct interface to LevelDB. <a href="https://github.com/rvagg/node-levelup">LevelUP</a> is the package that we recommend most people use for LevelDB in Node as it takes LevelDOWN and makes it much more Node-friendly, including the addition of those lovely <em>ReadStreams</em>.</p>
<p>Normally I wouldn&#39;t write a post about a minor release like this but this one seems significant because of a number of small changes that culminate in a <em>relatively</em> major release.</p>
<p><strong><em>In this post:</em></strong></p>
<ul>
<li><strong>V8 <code>Persistent</code> references</strong></li>
<li><strong><code>Persistent</code> in LevelDOWN; some removed, some added</strong></li>
<li><strong>Leaks!</strong></li>
<li><strong>Snappy 1.1.1</strong></li>
<li><strong>Some embarrassing bugs</strong></li>
<li><strong>Domains</strong></li>
<li><strong>Summary</strong></li>
<li><strong><em>A final note on Node 0.11.9</em></strong></li>
</ul>
<h3>V8 <code>Persistent</code> references</h3>
<p>The main story of this release are <code>v8::Persistent</code> references. For the uninitiated, V8 internally has two different ways to track &quot;handles&quot;, which are references to JavaScript objects and values currently active in a running program. There are <code>Local</code> references and there are <code>Persistent</code> references. <code>Local</code> references are the most common, they are the references you get when you create an object or pass them around within a function and do the normal work that you do with an object. <code>Persistent</code> references are a special case that is all about <em>Garbage Collection</em>. An object that has at least one active <code>Persistent</code> reference to it is not a candidate for garbage collection. <code>Persistent</code> references must be explicitly destroyed before they release the object and make it available to the garbage collector.</p>
<p>Prior to V8 3.2x.xx <em>(I don&#39;t know the exact version, does it matter? It roughly corresponds to Node v0.11.3.)</em>, these handles were both as easy as each other to create and interchange. You could swap one for the other whenever you needed. My guess is that the V8 team decided that this was a little <em>too</em> easy and that a major cause for memory leaks in C++ V8 code was the ease at which you could swap a <code>Local</code> for a <code>Persistent</code> and then forget to destroy the <code>Persistent</code>. So they tweaked the &quot;ease&quot; equation and it&#39;s become quite difficult.</p>
<p><code>Persistent</code> and <code>Local</code> no longer share the same type hierarchy and the way you instantiate and assign a <code>Persistent</code> has become quite awkward. You now have to go through enough gymnastics to create a <code>Persistent</code> that it makes you ask the question: <em>&quot;Do I really need this to be a <code>Persistent</code>?&quot;</em> Which I guess is a good thing for memory leaks. <a href="https://github.com/rvagg/nan">NAN</a> to the rescue though! We&#39;ve somewhat papered over those difficulties with the capabilities introduced in NAN, it&#39;s still not as easy as it once was but it&#39;s not a total headache.</p>
<p>So, you understand <code>v8::Persistent</code> now? Great, so back to LevelDOWN.</p>
<h3><code>Persistent</code> in LevelDOWN; some removed, some added!</h3>
<p><strong>Some removed</strong></p>
<p>Recently, <a href="https://github.com/mcollina">Matteo</a> noticed that when you&#39;re performing a <code>Batch()</code> operation in LevelDB, there is an explicit copy of the data that you&#39;re feeding in to that batch. When you construct a Batch operation in LevelDB you start off with a short string representing the batch and then build on that string as you build your batch with both <code>Put()</code> and <code>Del()</code> operations. You end up with a long string containing all of your write data; keys and values. Then when you call <code>Write()</code> on the Batch, that string gets fed directly into the main LevelDB store as a single write&mdash;which is where the atomicity of Batch comes from.</p>
<p>Both the chained-form and array-form <code>batch()</code> operations work this way internally in LevelDOWN.</p>
<p>However, with almost all operations in LevelDOWN, we perform the actual writes and reads against LevelDB in libuv worker threads. So we have to create the &quot;descriptor&quot; for work in the main V8 Node thread and then hand that off to libuv to perform the work in a separate thread. Once the work is completed we get the results back in the main V8 Node thread from where we can trigger a callback. This is where <code>Persistent</code> references come in.</p>
<p>Before we hand off the work to libuv, we need to make <code>Persistent</code> references to any V8 object that we want to survive across the asynchronous operation. Obviously the main candidate for this is <code>callback</code> functions. Consider this code:</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo = %s&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>

<p>What we&#39;ve actually done is create an anonymous closure for our callback. It has nothing referencing it, so as far as V8 is concerned it&#39;s a candidate for garbage collection once the current thread of execution is completed. In Node however, we&#39;re doing asynchronous work with it and need it to survive until we actually call it. This is where <code>Persistent</code> references come in. We receive the <code>callback</code> function as a <code>Local</code> in our C++ but then assign it to a <code>Persistent</code> so GC doesn&#39;t touch it. Once we&#39;re done our async work we can call the function and destroy the <code>Persistent</code>, effectively turning it back in to a <code>Local</code> and freeing it up for GC.</p>
<p>Without the <code>Persistent</code> then the behaviour is indeterminate. It depends on the version of V8, the GC settings, the workload currently in the program and the amount of time the async work takes to complete. If the GC is aggressive enough and has a chance to run before our async work is complete, the <code>callback</code> will disappear and we&#39;ll end up trying to call a function that no longer exists. This can obviously lead to runtime errors and will most likely crash our program.</p>
<p>In LevelDOWN, if you&#39;re passing in <code>String</code> objects for keys and values then to pull out the data and turn it in to a form that LevelDB can use we have to do an explicit <em>copy</em>. Once we&#39;ve copied the data from the <code>String</code> then we don&#39;t need to care about the original object and GC can get its hands on it as soon as it wants. So we can leave <code>String</code> objects as <code>Local</code> references while we are building the descriptor for our async work.</p>
<p><code>Buffer</code> objects are a different matter all together. Because we have access to the raw character array of a <code>Buffer</code>, we can feed that data straight in to LevelDB and this will save us one <em>copy</em> operation (which can be a significant performance boost if the data is significantly large or you&#39;re doing lots of operations&mdash;so prefer <code>Buffer</code>s where convenient if you need higher perf). When building the descriptor for the async work, we are just passing a character array to the LevelDB data structures that we&#39;re setting up. Because the data is shared with the original <code>Buffer</code> we have to make sure that GC doesn&#39;t clean up that <code>Buffer</code> before we have a chance to use the data. So we make a <code>Persistent</code> reference for it which we clean up after the async work is complete. So you can do this without worrying about GC:</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">).</span><span class="nx">randomBytes</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
  <span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo is now some random data!&#39;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>

<p>This has been the case in LevelDOWN for all operations since pretty much the beginning. But back to Matteo&#39;s observation. If LevelDB&#39;s data structures perform an explicit copy on the data we feed it then perhaps we don&#39;t need to keep the original data safe from GC? For a <code>batch()</code> call it turns out that we don&#39;t! When we&#39;re constructing the Batch descriptor, as we feed in data to it, both <code>Put()</code> and <code>Del()</code>, it&#39;s taking a copy of our data to create its internal representation. So even when we&#39;re using <code>Buffer</code> objects on the JavaScript side, we&#39;re done with them before the call down in to LevelDOWN is completed so there&#39;s no reason to save a <code>Persistent</code> reference! For other operations we&#39;re still doing some copying during the asynchronous cycle but the removal of the overhead of creating and deleting <code>Persistent</code> references for <code>batch()</code> calls is fantastic news for those doing bulk data loading (like Max Ogden&#39;s <a href="https://github.com/maxogden/dat">dat</a> project which needs to bulk load a <em>lot</em> of data).</p>
<p><strong>Some added</strong></p>
<p>Another gem from Matteo was reports of crashes during certain <code>batch()</code> operations. Difficult to reproduce and only under very particular circumstances, it seems to be mostly reproducible by the kinds of workloads generated by LevelGraph. Thanks to some simple C++ debugging we traced it to a dropped reference, obviously by GC. The code in question boiled down to something like this:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">doStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>In this code, the <code>batch</code> object is actually a LevelDOWN <code>Batch</code> object created in C++-land. During the <code>write()</code> operation, which is asynchronous, we end up with no hard references to <code>batch</code> in our code because the JS thread has yieled and moved on and the <code>batch</code> is contained within the scope of the <code>doStuff()</code> function. Because most of the asynchronous operations we perform are relatively quick, this normally doesn&#39;t matter. But for writes to LevelDB, if you have enough data in your write and you have enough data already in your data store, you can trigger a compaction upstream which can delay the write which can give V8&#39;s GC time to clean up references that might be important and for which you have no <code>Persistent</code> handles.</p>
<p>In this case, we weren&#39;t actually creating internal <code>Persistent</code> references for some of our objects. <code>Batch</code> in this case but also <code>Iterator</code>. Normally this isn&#39;t a problem because to use these objects you <em>generally</em> keep references to them yourself in your own code.</p>
<p>We managed to debug Matteo&#39;s crash by adjusting his test code to look something like this and watching it succeed without a crash:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">doStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">batch</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>By reusing <code>batch</code> inside our <code>callback</code> function, we&#39;re creating some work that V8 can&#39;t optimise away and therefore has to assume isn&#39;t a noop. Because the <code>batch</code> variable is also now referenced by the <code>callback</code> function and we already have an internal <code>Persistent</code> for it, GC has to pass over <code>batch</code> until the <code>Persistent</code> is destroyed for the <code>callback</code>.</p>
<p>So the solution is simply to create a <code>Persistent</code> for the internal objects that need to survive across asynchronous operations and make no assumptions about how they&#39;ll be used in JavaScript-land. In our case we&#39;ve gone for assigning a <code>Persistent</code> just prior to every asynchronous operation and destroying it after. The alternative would be to have a <code>Persistent</code> assigned upon the creation of objects we care about but sometimes we want GC to do its work:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">dontDoStuff</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">batch</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">()</span>
  <span class="nx">batch</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
  <span class="c1">// nothing else, wut?</span>
<span class="p">}</span>
</pre></div>

<p>I don&#39;t know why you would write that code but perhaps you have a use-case where you want the ability to start constructing a batch but then decide not to follow through with it. GC should be able to take care of your mess like it does with all of the other messes you create in your daily adventures with JavaScript.</p>
<p>So we are only assigning a <code>Persistent</code> when you do a <code>write()</code> with a chained-batch operation in LevelDOWN since it&#39;s the only asynchronous operation. So in <code>dontDoStuff()</code> GC will come along and rid us of <code>batch</code>, <code>&#39;foo&#39;</code> and <code>&#39;bar&#39;</code> when it has the next opportunity and our C++ code will have the appropriate destructors called that will clean up any other objects we have created along the way, like the internal LevelDB <code>Batch</code> with its copy of our data.</p>
<h3>Leaks!</h3>
<p>We&#39;ve been having some trouble with leaks in LevelUP/LevelDOWN lately <em>(<a href="https://github.com/rvagg/node-levelup/issues/171">LevelDOWN/#171</a>, <a href="https://github.com/mcollina/levelgraph/issues/40">LevelGraph/#40</a>)</em>. And it turns out that these leaks aren&#39;t related to <code>Persistent</code> references, which shouldn&#39;t be a surprise since it&#39;s so easy to leak with non-GC code, particularly if you spend most of your day programming in a language with GC.</p>
<p>With the help of <a href="http://valgrind.org/">Valgrind</a> we tracked the leak down to the omission of a <code>delete</code> in the destructor of the asynchronous work descriptor for array-batch operations. The internal LevelDB representation of a Batch wasn&#39;t being cleaned up unless you were using the chained-form of LevelDOWN&#39;s <code>batch()</code>. This one has been dogging us for a few releases now and it&#39;s been a headache particularly for people doing bulk-loading of data so I hope we can finally put it behind us!</p>
<h3>Snappy 1.1.1</h3>
<p>Google released a new version of Snappy, version 1.1.1. I don&#39;t really understand how Google uses <a href="http://semver.org/">semver</a>; we get very simple LevelDB releases with the minor version bumped and then we get versions of Snappy released with non-trivial changes with only the patch version bumped. I suspect that Google doesn&#39;t know how it uses semver either and there&#39;s no internal policy on it.</p>
<p>Anyway, Snappy 1.1.1 has some fixes, some minor speed and compression improvements but most importantly it breaks compilation on Windows. So we had to figure out how to fix that for this release. Ugh. I also took the opportunity to clean up some of the compilation options for Snappy and we may see some improvements in the way it works now... perhaps.</p>
<h3>Some embarrassing bugs</h3>
<p><a href="https://github.com/Kyotoweb">Amine Mouafik</a> is new to the LevelDOWN repository but has picked up some rather embarrassing bugs/omissions that are probably my fault. It&#39;s great to have more eyes on the C++ code, there&#39;s not enough JavaScript programmers with the confidence to dig in to messy C++-land.</p>
<p>Firstly, on our standard LevelDOWN releases, it turns out that we haven&#39;t actually been enabling the internal <strong>bloom filter</strong>. The bloom filter was introduced in LevelDB to speed up read operations to avoid having to scan through whole blocks to find the data a read is looking for. So that&#39;s now enabled for 0.10.</p>
<p>Then he discovered that we had been <strong>turning off compression</strong> by default! I believe this happened with the the switch to NAN. The signature for reading boolean options from V8 objects was changed from internal <code>LD_BOOLEAN_OPTION_VALUE</code> &amp; <code>LD_BOOLEAN_OPTION_VALUE_DEFTRUE</code> macros for defaulting to true and false respectively when the options aren&#39;t supplied, to the NAN version which is a unified <code>NanBooleanOptionValue</code> which takes an optional <code>defaultValue</code> argument that can be used to make the default <code>true</code>. This happened at roughly Node version 0.11.4.</p>
<p>Well, this code:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">compression</span> <span class="o">=</span>
    <span class="n">NanBooleanOptionValue</span><span class="p">(</span><span class="n">optionsObj</span><span class="p">,</span> <span class="n">NanSymbol</span><span class="p">(</span><span class="s">&quot;compression&quot;</span><span class="p">));</span>
</pre></div>

<p>is now this:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">compression</span> <span class="o">=</span>
    <span class="n">NanBooleanOptionValue</span><span class="p">(</span><span class="n">optionsObj</span><span class="p">,</span> <span class="n">NanSymbol</span><span class="p">(</span><span class="s">&quot;compression&quot;</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
</pre></div>

<p>so if you don&#39;t supply a <code>&quot;compression&quot;</code> boolean option in your db setup operation then it&#39;ll now actually be turned on!</p>
<h3>Domains</h3>
<p>We&#39;ve finally caught up with properly supporting Node&#39;s <a href="http://nodejs.org/docs/latest/api/domain.html">domains</a> by switching all C++ <code>callback</code> calls from standard V8 <code>callback-&gt;Call(...)</code> to Node&#39;s own <code>node::MakeCallback(callback, ...)</code> which does the same thing but also does lots of additional things, including accounting for domains. This change was also included in NAN version 0.5.0.</p>
<h3>Summary</h3>
<p><strong>Go and upgrade!</strong></p>
<p>leveldown@0.10.0 is packaged with the new levelup@0.18.0 and level@0.18.0 which have their minor versions bumped purely for this LevelDOWN release.</p>
<p>Also released are the packages:</p>
<ul>
<li>leveldown-hyper@0.10.0</li>
<li>leveldown-basho@0.10.0</li>
<li>rocksdb@0.10.0 (based on the same LevelDOWN code) (Linux only)</li>
<li>level-hyper@0.18.0 (levelup on leveldown-hyper)</li>
<li>level-basho@0.18.0 (levelup on leveldown-basho)</li>
<li>level-rocks@0.18.0 (levelup on rocksdb) (Linux only)</li>
</ul>
<p>I&#39;ll write more about these packages in the future since they&#39;ve gone largely under the radar for most people. If you&#39;re interested in catching up then please join <strong>##leveldb</strong> on Freenode where there&#39;s a bunch of Node database people and also a few non-Node LevelDB people like <a href="https://twitter.com/rescrv">Robert Escriva</a>, author of HyperLevelDB and all-round LevelDB expert.</p>
<h3><em>A final note on Node 0.11.9</em></h3>
<p>There will be a LevelDOWN@0.10.1 very soon that will increment the NAN dependency to 0.6.0 when it&#39;s released. This new version of NAN will specifically deal with Node 0.11.9 compatibility where there are more breaking V8 changes that will cause compile errors for any addon not taking them in to account. So if you&#39;re living on the edge in Node then we should have a release soon enough for you!</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="all-the-levels"><a href="/2013/10/all-the-levels.html">All the levels!</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 9, 2013</p>
        <p class="link"><a href="/2013/10/all-the-levels.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/all-the-levels.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>When we completely separated <a href="https://github.com/rvagg/node-levelup">LevelUP</a> and <a href="https://github.com/rvagg/node-leveldown">LevelDOWN</a> so that installing LevelUP didn&#39;t automatically get you LevelDOWN, we set up a new package called <strong><a href="https://github.com/Level/level">Level</a></strong> that has them both as a dependency so you just need to do <code>var level = require(&#39;level&#39;)</code> and everything is done for you.</p>
<p>But, we now have more than just the vanilla (Google) LevelDB in LevelDOWN. We also have a HyperLevelDB version and a Basho fork. These are maintained on branches in the LevelDOWN repo and are usually released now every time a new LevelDOWN is released. They are called <strong>leveldown-hyper</strong> and <strong>leveldown-basho</strong> in npm but you need to plug them in to LevelUP yourself to make them work. We also have <a href="https://github.com/rvagg/lmdb">Node LMDB</a> that&#39;s LevelDOWN compatible and a few others.</p>
<p>So, as of today, we&#39;ve released a new, small library called <strong><a href="https://github.com/level/level-packager">level-packager</a></strong> that does this bundling process so that you can feed it a LevelDOWN instance and it&#39;ll return a Level-type object that can be exported from a package like <strong>Level</strong>. This is meant to be used internally and it&#39;s now being used to support these new packages that are available in npm:</p>
<ul>
<li><strong><a href="https://github.com/Level/level-hyper">level-hyper</a></strong> bundles the HyperLevelDB version of LevelDOWN with LevelUP</li>
<li><strong><a href="https://github.com/Level/level-basho">level-basho</a></strong> bundles the Bash fork of LevelDB in LevelDOWN with LevelUP</li>
<li><strong><a href="https://github.com/Level/level-lmdb">level-lmdb</a></strong> bundles Node LMDB with LevelUP</li>
</ul>
<p>The version numbers of these packages will track the version of LevelUP.</p>
<p>So you can now simply do:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">level</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level-hyper&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">level</span><span class="p">(</span><span class="s1">&#39;/path/to/db&#39;</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;woohoo!&#39;</span><span class="p">)</span>
</pre></div>

<p>If you&#39;re already using <strong>Level</strong> then you can very easily switch it out with one of these alternatives to try them out.</p>
<p>Both HyperLevelDB and the Basho LevelDB fork are binary-compatible with Google&#39;s LevelDB, with one small caveat: with the latest release, LevelDB has switched to making <em>.ldb</em> files instead of <em>.sst</em> files inside a data store directory because of something about Windows backups (blah blah). Neither of the alternative forks know anything about these new files yet so you may run in to trouble if you have <em>.ldb</em> files in your store (although I&#39;m pretty sure you can simply rename these to <em>.sst</em> and it&#39;ll be fine with any version).</p>
<p>Also, LMDB is completely different to LevelDB so you won&#39;t be able to open an existing data store. But you should be able to do something like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">)(</span><span class="s1">&#39;/path/to/level.db&#39;</span><span class="p">).</span><span class="nx">createReadStream</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;level-lmdb&#39;</span><span class="p">)(</span><span class="s1">&#39;/path/to/lmdb.db&#39;</span><span class="p">).</span><span class="nx">createWriteStream</span><span class="p">())</span>
</pre></div>

<p>Whoa...</p>
<h3>A note about HyperLevelDB</h3>
<p>Lastly, I&#39;d like to encourage you to try the HyperLevelDB version if you are pushing hard on LevelDB&#39;s performance. The HyperDex fork is tuned for multi-threaded access for reads and writes and is therefore particularly suited to how we use it in Node. The Basho version doesn&#39;t show much performance difference mainly because they are optimising for Riak running 16 separate instances on the same server so multi-threaded access isn&#39;t as interesting for them. You should find significant performance gains if you&#39;re doing very heavy writes in particular with HyperLevelDB. Also, if you&#39;re interested in support for HyperLevelDB then pop in to ##leveldb on Freenode and bother <em><a href="https://twitter.com/rescrv">rescrv</a></em> (Robert Escriva), author of HyperLevelDB and our resident LevelDB expert.</p>
<p>It&#39;s also worth nothing that HyperDex are interested in offering commercial support for people using LevelDB, not just HyperLevelDB but also Google&#39;s LevelDB. This means that anyone using either of these packages in Node should be able to get solid support if they are doing any heavy work in a commercial environment and need the surety of experts behind them to help pick up the pieces. I imagine this would cover things like LevelDB corruption and any LevelDB bugs you may run in to (we&#39;re currently looking at a subtle <a href="https://github.com/rvagg/node-levelup/issues/171">batch-related LevelDB bug</a> that&#39;s come along with the 1.14.0 release, they do exist!). Talk to Robert if you want more information about commercial support.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="should-i-use-a-single-leveldb-or-many-to-hold-my-data"><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html">Should I use a single LevelDB or many to hold my data?</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 3, 2013</p>
        <p class="link"><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/should-i-use-a-single-leveldb-or-many-to-hold-my-data.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>This is a long overdue post, so long in fact that I can&#39;t remember who I promised to do this for! Regardless, I keep on having discussions around this topic so I thought it worthwhile putting down some notes on what I believe to be the factors you should consider when making this decision.</p>
<h3>What&#39;s the question?</h3>
<p>It goes like this: You have an application that uses LevelDB, in particular I&#39;m talking about Node.js applications here but the same would apply if you&#39;re using LevelUP in the browser and also most of the other back-ends for LevelUP. And you invariably end up with different kinds of data, sometimes the kinds of data you&#39;re storing is so different that it feels strange putting them into the same storage blob. Often though, you just have sets of not-very-related data that you need to store and you end up having to make a decision: <strong>do I put everything into a single LevelDB store or do I put things into their own, separate, LevelDB store?</strong></p>
<h3>This stuff doesn&#39;t <em>belong</em> together!</h3>
<p>Coming from an relational database background, it took me a little while to displace the concept of discrete <em>tables</em> with the notion of <em>namespacing</em> within the same store. I can understand the temptation to want to keep things separate, not wanting to end up with a huge blob of data that just <em>shouldn&#39;t be together</em>. But this isn&#39;t the relational database world and you need to move on!</p>
<p>We have a set of LevelUP addons, such as <a href="https://github.com/dominictarr/level-sublevel">sublevel</a>, that exist mainly to provide you with the comfort of being able to separate your data by whatever criteria makes sense. <a href="https://github.com/deanlandolt/bytewise">bytewise</a> is another tool that can serve a similar purpose and some people even use sublevel and bytewise together to achieve more complex organisation.</p>
<p><strong>We have the tools at our disposal in Node.js to turn a one-dimensional storage array into a very complex, multidimensional storage <em>system</em> where unrelated, and semi-related data can coexist.</strong> So, if the only reason you want to store things in separate stores is because it just <em>feels</em> right to do so, you should probably be looking at what&#39;s making you think that way. You may need to update your assumptions.</p>
<h3>Technical considerations</h3>
<p>That aside, there are some technical considerations for making this decision:</p>
<h4>Size and performance</h4>
<p>To be clear, <strong>LevelDB is fast</strong> and it can also store <strong>lots of data</strong>, it&#39;ll handle Gigabytes of data without too much sweat. However, there <em>are</em> some performance concerns when you start getting in to the Gigabyte range, mainly when you&#39;re trying to push data in at a high rate. Most use-cases don&#39;t do this so be honest about your performance needs. For most people LevelDB is simply fast.</p>
<p>However, if you do have a high-throughput scenario involving a large amount of data that you need to store then you may want to consider having a separate store to deal with the large data and another one to deal with the rest of your data so the performance isn&#39;t impacted across the board.</p>
<p>But again, be honest about what your workload is, you&#39;re probably not pushing <a href="http://voxer.com">Voxer</a> amounts of data so don&#39;t prematurely optimise around the workload you&#39;d like to think you have or are going to have one day in the distant future.</p>
<h3>Cache</h3>
<p>Caching is transparent by default with LevelDB so it&#39;s easy to forget about it when making these kinds of decisions but it&#39;s actually quite important for this particular question.</p>
<p>By default, you have an 8M LRU cache with LevelDB and <em>all</em> reads use that cache, for look-ups and also for updating with newly read values. So, you can have a lot of cache-thrash unless you&#39;re reading the same values again and again. </p>
<p>But, there is a <code>fillCache</code> (boolean) option for read operations (both <code>get()</code> and <code>createReadStream()</code> and its variations). So you can set this to <code>false</code> where you know you won&#39;t be needing fast access to those entries again and you don&#39;t want to push out other entries from the LRU.</p>
<p>So caching strategies can be separate for different types of data and are not a strong reason to keep things in a separate data store.</p>
<p>I always recommend that you should tinker with the <code>cacheSize</code> option when you&#39;re using LevelDB, it can be as large as you want to fit in the available memory of your machine. As a rule of thumb, somewhere between 2/3 and 3/4 of the available memory should be a maximum if you can afford it.</p>
<p>Consider though what happens if you are using separate LevelDB stores, you now have to deal with juggling <code>cacheSize</code> between the stores. Often, you&#39;re probably going to be best served by having a single, large cache that can operate across all your data types and let the normal behaviour of your application determine what gets cached with occasional reliance on <code>&#39;fillCache&#39;: false</code> to fine-tune. </p>
<h3>Consistency</h3>
<p>As I discussed in my <a href="http://r.va.gg/presentations/lxjs2013/">LXJS</a> talk, the <em>atomic batch</em> is an important primitive for building solid database functionality with inherent <em>consistency</em>. When you&#39;re using <strong>sublevel</strong>, even though you have what operate like separate LevelUP instances for each sublevel, you still get to perform atomic batch operations between sublevels. Consider indexing where you may have a primary sublevel for the entries you&#39;re writing and a secondary sublevel for the indexing data used to reference the primary data for lookups. If you&#39;re running these as separate stores then you lose the benefits of the atomic batch, you just can&#39;t perform multiple operations with guaranteed consistency.</p>
<p>Try and keep the atomic batch in mind when building your application, instead of accepting the possibility of inconsistent state, use the batch to keep consistency.</p>
<h3>Back-end flexibility</h3>
<p>OK, this one is a bit left-field, but remember that LevelUP is back-end-agnostic. It&#39;s inspired by LevelDB but it doesn&#39;t have to be Google&#39;s LevelDB that&#39;s storing data for you. It could be Basho&#39;s fork or HyperLevelDB. It could even be LMDB or something a little crazy like MemDOWN or mysqlDOWN! </p>
<p>If you&#39;re at all concerned about performance, and most people claim to be even though they&#39;re not building performance-critical applications, then you should be benchmarking your particular workload against your storage system. Each of the back-ends for LevelUP have different performance characteristics and different trade-offs that you need to understand and test against your needs. You may find that one back-end works for one kind of data in your application and another back-end works for another.</p>
<h3>Summary</h3>
<p>The TL;DR is: in most cases, a single LevelDB store is generally preferable unless you have a <em>real</em> reason for having separate ones.</p>
<p>Have I missed any considerations that you&#39;ve come across when making this choice? Let me know in the comments.</p>

      </section>

    </section>

  

    <section class="post-content">

      <h2 id="primitives-for-js-databases-an-lxjs-adventure"><a href="/2013/10/primitives-for-js-databases-an-lxjs-adventure.html">Primitives for JS Databases (an LXJS adventure)</a></h2>

      <div class="post-meta">
        <p class="byline">by Rod Vagg on October 3, 2013</p>
        <p class="link"><a href="/2013/10/primitives-for-js-databases-an-lxjs-adventure.html">Permalink &amp; Comments</a></p>
        <!-- <p class="commentcount"><a href="/2013/10/primitives-for-js-databases-an-lxjs-adventure.html#disqus_thread">Comments</a></p> -->
      </div>

      <section class="post-body">
        <p>I gave a talk yesterday at <strong><a href="http://2013.lxjs.org">LXJS</a></strong> yesterday in the <em>&quot;Infrastructure.js&quot;</em> block and tried to talk about JavaScript Database Primitives; i.e. the basic building blocks we have landed on for building more complex database solutions in JavaScript.</p>
<p>The talk certainly wasn&#39;t as good or clear as I wanted it to be, it worked much better in my head! A huge venue with over 300 talented JavaScripters, an absolutely massive screen, bright lights and loud amplification got the better of me and I wasn&#39;t able to pull the material together how I wanted to. The introvert within me is telling me to become a recluse for a little while just to recover! My <em>hope</em> is that at least one or two people are inspired to give <em>database hacking</em> a go because it&#39;s really not that difficult once you get your head around the primitives.</p>
<p><strong><em>Edit:</em></strong> <em>I wasn&#39;t trying to elicit sympathy here, I genuinely think that I wasn&#39;t clear on what I was trying to communicate. It went so well in my head, as it usually does, but I fell far short of what I wanted to express. I&#39;ll attempt to rectify some of that with a writeup (see next para).</em></p>
<p>Thankfully though, a portion of the material will be able to serve as the basis for the, long overdue, third part in my <a href="http://dailyjs.com/2013/04/19/leveldb-and-node-1/">three</a> <a href="http://dailyjs.com/2013/05/03/leveldb-and-node-2/">part</a> <a href="http://dailyjs.com">DailyJS</a> series on LevelDB &amp; Node.</p>
<p>In summary, inspired by LevelDB, we&#39;ve ended up with a core set of primitives in <a href="https://github.com/rvagg/node-levelup">LevelUP</a> that can be used to build feature-rich and advanced database functionality. <strong>Atomic batch</strong> and <strong>ReadStream</strong> are the two non-trivial primitives, open, close, get, put, del are all pretty easy to understand as primitives, although <em>del</em> is perhaps redundant but we&#39;re opting for explicitness.</p>
<p>My <a href="http://r.va.gg/presentations/lxjs2013">slides are online</a> but hopefully I&#39;ll be able to get my DailyJS article sorted out soon and I&#39;ll be able to explain what I was trying to get at.</p>
<p>ReadStream as a primitive query mechanism is not too hard to understand once you get your head around key sorting and the implications for key structure. Batch is a little more subtle and relates to consistency and our ability to augment basic operations to create more complex functionality while keeping the data store in a consistent state.</p>
<p>I additionally raised &quot;Buckets&quot;, or &quot;Namespaces&quot; as a primitive concept and discussed how <a href="https://github.com/dominictarr/level-sublevel">sublevel</a> has effectively become the standard for turning a one-dimensional data store into a multi-dimensional store able to encapsulate contain sophisticated functionality behind what is essentially just a key/value store.</p>
<h3>Thanks to the LXJS team</h3>
<p>It would be neglectful of me to not say how absolutely grateful I am to the LXJS team for putting so much effort into taking care of speakers; fantastic job.</p>
<p>LXJS is an amazing event, put on by a dedicated and very talented team of people committed to the JavaScript community and the JavaScript community in Portugal in particular. This conference sets a very high bar for community-driven conferences with the way it has managed to get so many locals (and internationals!) involved in running an event in their own time.</p>
<p><strong>David Dias, Ana Hevesi, Pedro Teixeira, Luís Reis, Nuno Job, Tiago Rodrigues, Leo Xavier, Alexander Kustov, André Rodrigues and Bruno Coelho</strong> have managed to put on an amazing event and are some of the nicest and talented people I&#39;ve met. Thank you to you all and everyone else who put on LXJS 2013, your hard work is appreciated and should be an inspiration to everyone involved in our local JavaScript communities, running events or considering running events like this.</p>

      </section>

    </section>

  
</div>

  <section class="pager">
    
 

      <div class="next">
        <a href="/page1.html">&laquo; Older posts</a>
      </div>

    
  </section>
  <div style="clear: both;"></div>

  <!--
  <script type="text/javascript">
    var disqus_shortname = 'rvagg'

    !(function () {
      var s = document.createElement('script')
      s.async = true
      s.type = 'text/javascript'
      s.src = 'http://' + disqus_shortname + '.disqus.com/count.js'
      !(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s)
    }())
  </script>
  -->



      <section class="footer">
        &copy; Rod Vagg 2013, powered by <a href="https://github.com/rvagg/blorg">Blorg</a>
        <br><a href="http://r.va.gg/atom.xml">Atom / RSS feed</a>
      </section>

    </section>

  </body>
</html>